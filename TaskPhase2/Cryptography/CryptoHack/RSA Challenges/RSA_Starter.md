# RSA Starter

---

## Modular Exponentiation

### Challenge

![image](https://github.com/user-attachments/assets/06d96683-6f31-4f55-97d9-1fa406a3a902)

### Solving

Pretty straightforward challenge as context was provided.

**To note:**

This is a function that is easy to compute in one direction, but hard to do in reverse unless you have the right information. It allows us to encrypt a message, and only the person with the key can perform the inverse operation to decrypt it.

```python
base = 101
exponent = 17
modulus = 22663

# Calculate modular exponentiation
result = pow(base, exponent, modulus)
print("101^17 mod 22663 =", result)  
```

Output:

``101^17 mod 22663 = 19906``

### Flag

> 10^1 mod 22663 = 19906

---

## Public Keys

### Challenge

![image](https://github.com/user-attachments/assets/d9554ee4-7f2f-431a-9c68-f08c5ee85415)

### Solving

**NOTE:** Encryption for RSA is done with ``pt^e % N`` pt = plain text

So likewise we just use the similar function as before....

```
print(pow(12, 65537, 17*23))
```

### Flag

> 301

---

## Euler's Toitent

### Challenge

![image](https://github.com/user-attachments/assets/d8d7687d-eadd-4c2b-9e90-93b158e673a1)

### Solving

Over here we find out that ``ϕ(N) = (p-1)(q-1)`` if **N = p*q**

```python
p = 857504083339712752489993810777
q = 1029224947942998075080348647219
toit = (p-1)*(q-1)
print(toit)
```

Output:

``882564595536224140639625987657529300394956519977044270821168``

### Flag

> 882564595536224140639625987657529300394956519977044270821168

---

## Private Keys

### Challenge

![image](https://github.com/user-attachments/assets/63b50a70-b78f-4564-b7f3-7a9154a16a55)

### Solving

**Note:** The private key d is used to decrypt ciphertexts created with the corresponding public key. The private key is the secret piece of information, or "trapdoor", which allows us to quickly invert the encryption function.

Now like before they seem to have given us a formula which evaluates to ``e^-1 % ϕ(N)`` Now like in the first challenge we know this directly
can be done with ``pow(e, -1, ϕ(N))``

```python
p = 857504083339712752489993810777
q = 1029224947942998075080348647219
toit = (p-1)*(q-1)
e = 65537
print(pow(e, -1, toit))
```

### Flag

> 121832886702415731577073962957377780195510499965398469843281

---

## RSA decryption

### Challenge

![image](https://github.com/user-attachments/assets/94189ee0-998c-4f50-b554-65213a38e49c)

### Solving

**Private Key from previous challenge:** ``d = 121832886702415731577073962957377780195510499965398469843281``

Decryption for RSA is done by ``c^d % N`` c = ciphertext

```python
d = 121832886702415731577073962957377780195510499965398469843281
c = 77578995801157823671636298847186723593814843845525223303932
N = 882564595536224140639625987659416029426239230804614613279163

print(pow(c, d, N))
```

### Flag

> 13371337

---

## RSA Signatures

### Challenge

![image](https://github.com/user-attachments/assets/e26ce743-354c-44f2-b9fa-a9d26fed1b0c)

TextFile Provided:

```
N = 15216583654836731327639981224133918855895948374072384050848479908982286890731769486609085918857664046075375253168955058743185664390273058074450390236774324903305663479046566232967297765731625328029814055635316002591227570271271445226094919864475407884459980489638001092788574811554149774028950310695112688723853763743238753349782508121985338746755237819373178699343135091783992299561827389745132880022259873387524273298850340648779897909381979714026837172003953221052431217940632552930880000919436507245150726543040714721553361063311954285289857582079880295199632757829525723874753306371990452491305564061051059885803
d = 11175901210643014262548222473449533091378848269490518850474399681690547281665059317155831692300453197335735728459259392366823302405685389586883670043744683993709123180805154631088513521456979317628012721881537154107239389466063136007337120599915456659758559300673444689263854921332185562706707573660658164991098457874495054854491474065039621922972671588299315846306069845169959451250821044417886630346229021305410340100401530146135418806544340908355106582089082980533651095594192031411679866134256418292249592135441145384466261279428795408721990564658703903787956958168449841491667690491585550160457893350536334242689
```

### Solving

**Note:** To sign message ``hash^d % n``

Now to hash this message with a signature first of all convert the string to byte string then hash it with SHA256.

The .digest() method of a hash object returns the hash of the data as a byte string. The ``bytes_to_long`` then take the byte string and converts it to a long integer. 

```python
from Crypto.Hash import SHA256
from Crypto.Util.number import bytes_to_long

n = 15216583654836731327639981224133918855895948374072384050848479908982286890731769486609085918857664046075375253168955058743185664390273058074450390236774324903305663479046566232967297765731625328029814055635316002591227570271271445226094919864475407884459980489638001092788574811554149774028950310695112688723853763743238753349782508121985338746755237819373178699343135091783992299561827389745132880022259873387524273298850340648779897909381979714026837172003953221052431217940632552930880000919436507245150726543040714721553361063311954285289857582079880295199632757829525723874753306371990452491305564061051059885803
d = 11175901210643014262548222473449533091378848269490518850474399681690547281665059317155831692300453197335735728459259392366823302405685389586883670043744683993709123180805154631088513521456979317628012721881537154107239389466063136007337120599915456659758559300673444689263854921332185562706707573660658164991098457874495054854491474065039621922972671588299315846306069845169959451250821044417886630346229021305410340100401530146135418806544340908355106582089082980533651095594192031411679866134256418292249592135441145384466261279428795408721990564658703903787956958168449841491667690491585550160457893350536334242689

hash = SHA256.new(data=b'crypto{Immut4ble_m3ssag1ng}')
s = pow(bytes_to_long(hash.digest()), d, n)
print(s)
```

### Flag

> 33860734724124228305158914225250488399673645732882077575252662461860972889771112594906884441454355959482925283992539925713424132009768721389828848907099772040836383856524605008942907083490383109757406940540866978237471686296661685839083475

---

## **NOTES**

RSA encryption allows for secure communication by using a **public key** for encryption and a **private key** for decryption. The strength of RSA lies in the difficulty of factoring large numbers and the reversible nature of modular exponentiation when the private key is known.

- **Public Key (N, e)**: Used for encrypting messages.
- **Private Key (d)**: Used for decrypting messages, calculated using Euler’s Totient.
- **Modulo (N)**: ``(p * q)``
- **Totient Function**: ``φ(N) = (p - 1) * (q - 1)``
- **Private key formula**: ``d ≡ e^{-1} % φ(N)``
- **Encryption Formula**: ``c = m^e % N``
- **Decryption Formula**: ``m = c^d % N``
- **Signing a message**: ``S = digest^d % n``
- **Reverting the Sign**: ``S^e % n = digest``

*important*: If the digest after reverting the signing of the message is not the same as the previous message you know it has not been signed properly.
