# Server-side request forgery

## Notes

Server-side request forgery is a web security vulnerability that allows a hacker to cause the server-side application to make requests to an unintended location.

How it works generally:

- The hacker sends a request to a vulnerable server.
- The server believing itâ€™s legit forwards the request to another internal or external system.
- The hacker can access sensitive internal data or exploit external systems

This can cause several issues 

- Internal System Access: Hackers can access internal services that are not meant to be public
- Data Leaks: Sensitive informations are released
- Command Execution: Attackers are able to run arbitary commands

---

## Basic SSRF against the local server

### Challenge

```
This lab has a stock check feature which fetches data from an internal system.

To solve the lab, change the stock check URL to access the admin interface at http://localhost/admin and delete the user carlos.
```

### Solution

From the description of the challenge we can understand that we have to exploit the vulnerability that is the ``stock check`` functionality.

Upon opening the website we realise it is a virtual shop. Checking one of the items we see an option for the stock check feature.
We can select 3 cities and it will print the stock of the item.

Now lets open this up in burpsuite by intercepting a request when checking stock for an item. Seeing the requests headers everything seems about normal except for the header ``stockApi`` This seems to encompass a sort of URL. I first send this to repeater for ease of change and results viewing.

![image](https://github.com/user-attachments/assets/a70db720-668d-4da5-b8b0-528dc3b186cc)

From here I can decode what stockAPI is equal to which is ``http://stock.weliketoshop.net:8080/product/stock/check?productId=1&storeId=1``
Now from what i can assume here is that they have provided us a direct way to access and look around the other areas of this website. 

This always seems to access a URL of sorts so why don't i try to use it to poke around areas I shouldn't for eg they did say there is an admin interface at ``http://localhost/admin``. Accessing ``localhost`` can potentially allow us to view internal directories and gain insight into the working of the website. So lets first look at the localhost by changing our ``stockApi = http://localhost/`` From here I am able to see the same application however I am able to see it from the localhost's view meaning i may see things I was not able to see on the regular website. In this case moving the response to render I can see an **admin panel**

![image](https://github.com/user-attachments/assets/5e5e89b5-60bd-4686-9db5-88e3c5288335)

Going back to pretty to see how to access it I find the directory which is /admin.

![image](https://github.com/user-attachments/assets/f7eddd2a-1988-4393-90c6-d96aebf77406)

Now changing ``stockApi =  http://localhost/admin`` we can see the admin panel that has 2 Users carlos and wiener and it also provides an option to delete. Now from here i can go back to prettyand look for carlos.

![image](https://github.com/user-attachments/assets/a60a3625-be3d-4adb-ad0c-695ba9ffbe5f)

From here I am able to find a directory ``/admin/delete?username=carlos`` so from here i change ``stockApi = http://localhost/admin/delete?username=carlos`` doing this we get an option to follow redirection. 

Following this twice we get a render that the challenge has been solved.

![image](https://github.com/user-attachments/assets/803051c2-b20c-4a8d-ba99-1b7df83aa6e8)

---

## Basic SSRF against another back-end system

### Challenge

```
This lab has a stock check feature which fetches data from an internal system.

To solve the lab, use the stock check functionality to scan the internal 192.168.0.X range for an admin interface on port 8080, then use it to delete the user carlos.

```

### Solution

Like the last challenge we have a digital store on the website where me must again use the stock check functionality to search for an admin interface on the 192.168.0.X with port 8080. And again delete carlos.

Loading it into burpsuite we first enter any item and try changing the stock. After th at just send the request to repeater.
Like the last lab we see the request header for ``stockApi`` Decoding the URL encoded we can see it is calling a domain this time rather than a URL.

``http%3A%2F%2F192.168.0.1%3A8080%2Fproduct%2Fstock%2Fcheck%3FproductId%3D1%26storeId%3D1`` converted -> ``http://192.168.0.1:8080/product/stock/check?productId=1&storeId=1`` 

From here we can understand that we have to scan for other applications that are running on the IP range ``192.168.0`` with port ``8080``
To do that. Luckily we can bruteforce a valid value for x to get the correct IP address. This is because trying nearly 255 Numbers would be crazy and long. 
The reason there could be 255 IP addresses is because this IP address is of the format **IPv4** consisting of four numbers seperated by dots the numbers can range from 0 to 255.

![image](https://github.com/user-attachments/assets/ba4961be-4d73-480d-af8e-998c9e0a00b7)

We send this request to intruder first clearing all the positions and essentially adding our IP address in the stockApi with the payload parameter provided by burpsuite. Then we need to setup this payload by first setting the payload type to numbers. then making the options 0 to 255 with a step range of 1. Finally we can start the attack.

From here i wait a while until most of the attack is done. Now we end up seeing alot of addresses with status code of 500 which is an internal server error. A status code of 400 means there was a bad request which seems to start from the payload of 1.

After waiting a couple of minutes the payload finally finishes and we see that the payload of ``157`` returns a 404 status code. Meaning this server is running but the page we are accessing does not exist.

![image](https://github.com/user-attachments/assets/dec4e1e8-1ed6-4267-bac9-963a7c553ec2)

So lets send this to repeater. Now like the challenge description lets access ``/admin`` by appending it to the URL.

We end up getting to see the admin page from here we look for the delete carlos user part. Once found we find out the URL is /http://192.168.0.157:8080/admin/delete?username=carlos
Now we can just send a request to it 

![image](https://github.com/user-attachments/assets/c3eaa727-955a-444f-8c5a-4cf8daf8d0cb)

Sending this completes the challenge.

---

## SSRF with blacklist-based input filter

### Challenge

```
This lab has a stock check feature which fetches data from an internal system.

To solve the lab, change the stock check URL to access the admin interface at http://localhost/admin and delete the user carlos.

The developer has deployed two weak anti-SSRF defenses that you will need to bypass.
```

### Solution

This challenge seems similar to the first where we have to exploit the stockApi where we have to delete carlos.
However this time there are two weak SSRF defenses. 

Like before send the request headers where it is asking for ``stockApi`` to the repeater.

First trying to make it access the local host by entering ``stockApi=http://localhost/`` Doing this gives a message *"External stock check blocked for security reasons"*
Now let us try accessing ``127.0.0.1`` which is the default IPv4 address for the loopback interface, equivalent to localhost which may bypass what we where trying earlier.

However it is still blocked. Now we have another alternative IP address which is ``127.1`` Which ends up resolving to ``127.0.0.1``
We can also try finding the decimal conversion of ``127.0.0.1`` by using [IP Address guide](https://www.ipaddressguide.com/ip) which is ``2130706433``

Where we end up seeing the admin panel which is accessable by using the ``/admin``

![image](https://github.com/user-attachments/assets/a4588a84-e96e-47b9-981b-aacf97af43b0)

So now we make our ``stockApi=http://127.1/admin``

However trying this does not allow us to access it. Now trying to URL encode it will also not work. What we can assume is it is searching for both the admin string and the url encoded versions of admin by decoding it once..

Now a way to get around this would be to URL encode admin twice. This works as once we have encoded it twice. 
When it is decoded once by the checks in place by the server it will have the URL encoded form of admin. which is not being checked for. Hence it will work

Our payload now becomes ``stockApi=http://127.1/%25%36%31%25%36%34%25%36%64%25%36%39%25%36%65``

This shows us our admin panel Now from here we search for the URL to delete carlos which is ``/admin/delete?username=carlos``

![image](https://github.com/user-attachments/assets/61966be0-8e36-4075-8831-21c733a042f8)

and our final payload becomes ``stockApi=http://127.1/%25%36%31%25%36%34%25%36%64%25%36%39%25%36%65/delete?username=carlos`` to which we solve the challenge.

---

## SSRF with filter bypass via open redirection vulnerability

### Challenge

```
This lab has a stock check feature which fetches data from an internal system.

To solve the lab, change the stock check URL to access the admin interface at http://192.168.0.12:8080/admin and delete the user carlos.

The stock checker has been restricted to only access the local application, so you will need to find an open redirect affecting the application first.

```

### Solution

Again we have to exploit the stockApi request header to delete the user carlos. Now we can only do this using an open redirect exploit.

Upon opening one of the items pages we see the stock check functionality is available and we also see a new option called *next product*

Another intresting thing is unlike the previous challenges when trying to use the stockcheck feature I am able to see that it is not using a URL which is ``/product/stock/check?productId=1&storeId=1`` This means we cant pass the URL that we know such as ``localhost`` or ``127`` ip.

Looking at next product page we see something intresting in burp suite which is the request header for the method. which is ``/product/nextProduct?currentProductId=1&path=/product?productId=2`` This seems to be redirecting us from the first product to the second product. 

Now instead of having ``/product?productId=2`` here what if i try putting our URL to the admin panel ```http://192.168.0.12:8080/admin``

This changes the request header to ``/product/nextProduct?currentProductId=1&path=http://192.168.0.12:8080/admin``. This seems to be giving a valid response upon trying. So we know this sort of redirection works and we have to use it with stockApi.

So now going back to the first products page we can then change our payload to be ``stockApi=/product/nextProduct?currentProductId=1&path=http://192.168.0.12:8080/admin`` However when trying this we get a message **"Missing parameter 'path'"** to which we understand that it is not in the correct form. 
So we URL encode the entire thing. which becomes ``stockApi=%2f%70%72%6f%64%75%63%74%2f%6e%65%78%74%50%72%6f%64%75%63%74%3f%63%75%72%72%65%6e%74%50%72%6f%64%75%63%74%49%64%3d%31%26%70%61%74%68%3d%68%74%74%70%3a%2f%2f%31%39%32%2e%31%36%38%2e%30%2e%31%32%3a%38%30%38%30%2f%61%64%6d%69%6e`` 

This shows us the admin panel. from here we search for the way to delete carlos which is ``/http://192.168.0.12:8080/admin/delete?username=carl``

![image](https://github.com/user-attachments/assets/3bbad147-6b7f-4e8e-8dc3-8d974283e132)

from here we make our payload ``stockApi=/product/nextProduct?currentProductId=1&path=http://192.168.0.12:8080/admin/delete?username=carlos``
We then encode it like before to become ``stockApi=%2f%70%72%6f%64%75%63%74%2f%6e%65%78%74%50%72%6f%64%75%63%74%3f%63%75%72%72%65%6e%74%50%72%6f%64%75%63%74%49%64%3d%31%26%70%61%74%68%3d%68%74%74%70%3a%2f%2f%31%39%32%2e%31%36%38%2e%30%2e%31%32%3a%38%30%38%30%2f%61%64%6d%69%6e%2f%64%65%6c%65%74%65%3f%75%73%65%72%6e%61%6d%65%3d%63%61%72%6c%6f%73``

And hence the lab is solved.

![image](https://github.com/user-attachments/assets/275ed037-f7e1-473c-8716-86027c727351)

---

## SSRF with whitelist-based input filter

### Challenge
```
This lab has a stock check feature which fetches data from an internal system.

To solve the lab, change the stock check URL to access the admin interface at http://localhost/admin and delete the user carlos.

The developer has deployed an anti-SSRF defense you will need to bypass.
```

### Solution

Now similar to the last challenge we first try seeing what the checkstock feature does by sending to repeater.

Over here lets try changing the ``stockApi`` to ``http://localhost/admin`` trying this we recieve an error message **"External stock check host must be stock.weliketoshop.net"**. From this we can assume application parses the URL and extracts the hostname validating it against the whitelist and the whitelist has to be ``stock.weliketoshop.net`` This means we need to use this input else it will never work.

Now a way to possibly get around this is adding a ``http://string@stock.weliketoshop.net`` as our payload. This is a similar exploit to that of *userinfo component*. The URL is using the string part before the @ synmbol and does not affect the hostname that we use. This means the request will still be sent to stock.weliketoshop.net which is the valid whitelisted hostname

Upon trying this we face an error that it **could not connect to external stock change service**. So how about i put the URL in there and see what happens.

``http://localhost@stock.weliketoshop.net`` trying it like this tells us the  **could not connect to external stock change service**


Going back to the string stuff if we add a ``# `` which is also known as a fragment identifier it causes the portion of the URL after it to be ignored by the server. Trying this with payload ``http://string#@stock.weliketoshop.net`` shows the message we saw before **"External stock check host must be stock.weliketoshop.net"** Now essentially what is doing is its seeing ``http://string`` as a url and not seeing the rest of the string. 

Now like before we can assume that this parser is looking for this # and immediately cuts it out like a blacklist. So trying to encode it once and trying shows the same error but encoding it twice seems to not give this error it treats the double encoded ``#`` as part of the hostname, allowing the URL to pass through the parsing logic without causing it not to see the second half. The parser does not see *#* as a fragment separator anymore and allows the rest of the string to be considered as part of the domain

``stockApi=http://string%2523@stock.weliketoshop.net`` payload now looks like this giving **could not connect to external stock change service**

What this essentially is doing is allowing us to seperate the URL keeping the first part as our literal URL to connect to and what comes after to bypass the whitelist. By encoding the ``#`` twice we can understand that the parser does not recognise this as the encoded fragment to cut out the rest of the string.

Now lets give it our URL that we want to access.

``stockApi=http://localhost%2523@stock.weliketoshop.net``

Using this shows us the admin panel. Now we find out what we need to access is ``/admin`` however to do this we need to add it at the end of our payload. 
This is because if we are adding it after ``localhost`` it will be interpreted as part of the hostname. So adding it at the end ensures the server correctly processes the domain and path we want to access seperately. 

![image](https://github.com/user-attachments/assets/58ca4914-388c-48e0-a9b0-701606847e68)

After this we make our payload ``stockApi=http://localhost%2523@stock.weliketoshop.net/admin`` Hence showing us the admin page looking 
through this we find the speicifc query to delete carlos which is ``/admin/delete?username=carlos``

![image](https://github.com/user-attachments/assets/75eb296a-3670-4844-9cf6-e8e7292e1474)


Now like before appending this to the end of the payload we solve the challenge

``http://localhost%2523@stock.weliketoshop.net/admin/delete?username=carlos``

![image](https://github.com/user-attachments/assets/5cd4aa02-d24d-4fab-8c2f-67dfb5f2209b)

---

Proof of Solve:

![image](https://github.com/user-attachments/assets/e563ff21-61ac-46e8-9f09-a4ac4c00ec1c)


