# Cross-site scripting

## Notes

Cross-site scripting (XSS) is a security vulnerability where attackers inject malicious code (usually JavaScript) into a website that other users visit. This happens because the website does not properly validate or sanitize input before displaying it.

This allows the attackers to do these things

- Pretend to be a logged in user peforming actions on their behalf
- Steal data such as login creds, session cookies and personal info of the user
- If the user they are pretending to be is an Admin they gain full access to the application

But how does the attacker gain access to a user of the website's capabilities.

The attacker injects or puts in harmful code into the website. When a user visits this website the browser they are using runs this harmful code. The hacker can then take over the user's experience, steal info and act as them.

The attacker generally finds an input field on the website or even the url to inject their code. The website will not sanitize or validate this input properly so it embeds this malicious code into the page's response (Essentially what is returned when browser makes request to server)

When a user then opens the website the browser interprets and runs the malicious script as if it were part of the legitimate website. It runs with the same permissions as the rest of the website so the browser trusts it. The attacker can then take over the user's experience, steal info and act as them.

Three types of XSS attacks
- Reflected XSS
- Stored XSS
- DOM-based XSS

### Reflected XSS

This is not a case where the website's text fields are used to inject malicious code into the database. the attacker crafts malicious URLs or HTTP requests that include harmful code. This code is inserted into the query parameter into a URL. The user is then tricked into clicking the link. When opened it sends a request to the server. The server reflects the malicious input back into the response without sanitizing or escaping it. The script then runs in the user's browser stealing info etc.

Eg:

```
http://example.com/search?q=<script>alert('Hacked!')</script>
```


### Stored XSS

This is the general XSS that we know of where the hacker enters malicious code into text fields present on a website. The web server ends up saving this in its database. A user then visits the page that contains the attackers malicious code as it was fetched from the saved database.
The victims browser then executes the malicious code.


### DOM-based XSS

DOM -> Document Object Model <br>
It is a way web browsers represent the structure of a web page. When web pages load the browser creates this from the HTML, CSS and javascript. JavaScript can then interact with the DOM to change the content of the webpage

The vulnerability occurs when a website’s client-side JavaScript takes user input (malicious code) and displays it on the webpage without proper validation or sanitization. This allows an attacker to inject malicious scripts into the page, which are then executed in the victim’s browser. 

Unlike STORED XSS, the malicious code is not stored on the server but rather within the browser's DOM. When the page is loaded or interacted with the script runs.

---

## Reflected XSS into HTML context with nothing encoded


### Challenge

```
This lab contains a simple reflected cross-site scripting vulnerability in the search functionality.

To solve the lab, perform a cross-site scripting attack that calls the alert function.
```

### Solving

Upon reading the description we understand that we must have a alert box pop up on our web page.

Now opening the web page we see the textbox we are supposed to enter our `malicious` code.

When trying XSS the first thing most people would enter is some html code or javascript and see if it reflects (Input is directly entered into the webpage)
Essentially we want to see if it is treated as a html tag where we can insert our code to give an alert box.

So first i enter ``<test>`` as a input to see wether the webpage sanitizes my input preventing me from putting in malicious code. However there is no visual way to check wether it was sanitized or not. 

Our job here is to check the source code of the page which we can see by entering *CTRL + U*
Now over here we can just search for `<test>` that we entered to see if it was sanitized or not.

![image](https://github.com/user-attachments/assets/93265e5b-cd89-4f8b-98b9-cdd0585a924a)

And lucky us it is not. what reflects ``<h1>0 search results for '<test>'</h1>`` showing that we can use html or javascript to insert code for an alert. 

**Note:** If the input was sanitized we would see ``<h1>0 search results for '&lt;test&gt;'</h1>`` where the ``<`` would be converted to ``&lt;`` and ``> to &gt;``

As such to solve now we can just create a payload to create an alert using javascript that is inside a html document.

```javascript
<script>alert('haxor')</script>
```

``<script>`` and ``</script>`` are html tags used to embed or reference javascript code anything written between these will be treated as javascript by the browser

``alert('haxor')`` essentially creates a pop-up alert box which is what we need to complete the lab.

![image](https://github.com/user-attachments/assets/1607c0af-62ea-43a9-9200-179ebdef45e6)

Entering this gives a popup and exiting out of it shows the lab is completed.

---

## Stored XSS into HTML context with nothing encoded

### Challenge

```
This lab contains a stored cross-site scripting vulnerability in the comment functionality.

To solve this lab, submit a comment that calls the alert function when the blog post is viewed.

```

### Solving

Now essentially we have to do the same thing as before make a script for a text field to send an alert

Opening the website we see that it is a blogpost of sorts very cool with a bunch of different articles we enter the first one, with our comments section being at the bottom.
However now there are 4 text fields not just one so lets test all of them. Trying to enter ``<test>`` into all of them does not work as 2 of the text fields require an email and
website so we enter those. Once we choose the post comment it allows us to go back to the article to see our newly posted comment.

From here everything seems normal so lets open up the source code for the page 
Upon doing so we find out one of 2 text fields we entered was infact sanitized but the other was not.

![image](https://github.com/user-attachments/assets/d69959e2-0ca4-4357-88a6-cda2928adaa8)

We can see that the second text field which takes our name is sanitized hence the Comment: text field should allow us to write our payload to finish this lab.

Entering this into the comment section: 

```javascript
<script>alert('haxor')</script>
```

and filling the rest normally we are able to submit a comment and going back to the article we get the alert button we want and exiting out of it back to the article we confirm the lab has been completed

---

## DOM XSS in document.write sink using source location.search

### Challenge

```
This lab contains a DOM-based cross-site scripting vulnerability in the search query tracking functionality. It uses the JavaScript document.write function, which writes data out to the page. The document.write function is called with data from location.search, which you can control using the website URL.

To solve this lab, perform a cross-site scripting attack that calls the alert function.
```

### Solving

Like before we have a website with a search query area. Now lets first test our payload in the very big search bar they provided ``test`` after doing this
we can proceed to check the source code of the page

Unluckily it seems as though they have sanitised the possible inputs we can give. However there is another script highlighted by the source code checker

![image](https://github.com/user-attachments/assets/e78202dd-d4ae-41c5-8da1-e608f3b10da3)

```javascript
<script>
    function trackSearch(query) {
        document.write('<img src="/resources/images/tracker.gif?searchTerms=' + query + '">');
    }
    var query = (new URLSearchParams(window.location.search)).get('search');
    if (query) {
        trackSearch(query);
    }
</script>
```
Over here we have a variable called query that was passed to the function This is taken from the ``search`` parameter given.

``document.write('<img src="/resources/images/tracker.gif?searchTerms=' + query + '">');``
It then does a now another intresting thing it is doing is writes an ``<img>`` to the document. essentially adding a image. 
Now whenever changes have been made to web pages we should inspect the page. In this case we know an image has been made.

This we can see here

``<img src="/resources/images/tracker.gif?searchTerms=<test>">``

We understand it is using a textfield to sanitize the input not allowing us to inject our payload allowing it to execute. So why dont we close the input area that it looks at and enter our payload after?

From this we can figure out a way to bypass this using a similar method to SQL injection by first closing the textfield by making our entered item **">**
after this we can reuse our previous payload 

```javascript
<script>alert('haxor')</script>
```

Hence our final payload will look like this

``"><script>alert('haxor')</script>``

As such we complete the challenge.

---

## DOM XSS in innerHTML sink using source location.search


### Challenge

```
This lab contains a DOM-based cross-site scripting vulnerability in the search blog functionality. It uses an innerHTML assignment, which changes the HTML contents of a div element, using data from location.search.

To solve this lab, perform a cross-site scripting attack that calls the alert function.
```

### Solving

Again we first start with ``<test>`` which we can see was sanitised upon looking at the source code. We also seem to see a similar function as the last challenge 
this time however ``document.getElementById('searchMessage').innerHTML = query;`` instead. 

![image](https://github.com/user-attachments/assets/0bde041e-6805-413a-a190-d6dfd8178542)

Now let me try inspecting it we see it is quite different compared to last time just showing ``<test> <\test>``

![image](https://github.com/user-attachments/assets/c0f578ca-109c-43a2-8710-e050c25bfac0)

However now trying ``<script>alert('haxor')</script>`` shows the entire script just not executed...

![image](https://github.com/user-attachments/assets/e2ec8b90-48a4-402e-987e-9d27e0ea5f84)

It has not executed the script tags. This is because of the way its taking the input ``document.getElement`` will not be executing the script tags. Hence we must make a new payload  

```javascript
<img src=x onerror=prompt(1)>
```

Over here this payload ``<img src=x`` expects an image with the URL from x however this does not exist in the url causing an error. The one error event handler triggers when the image fails to load showing an alert function similar to what we did before.

and it works finishing the lab.

---

## DOM XSS in jQuery anchor href attribute sink using location.search source

### Challenge

```
This lab contains a DOM-based cross-site scripting vulnerability in the submit feedback page. It uses the jQuery library's $ selector function to find an anchor element, and changes its href attribute using data from location.search.

To solve this lab, make the "back" link alert document.cookie.
```

### Solving

From the challenge description we understand that there is a jQuery code that takes data from the url and assigning it to a href attribute of a particular anchor element of a page.
Opening the web page we see the submit feedback area to which we enter.
 
When we enter this something intresting happens in the URL where we see a ``/feedback?returnPath=/``
As we know this uses jQuery lets first see what the source code for the web page. We end up seeing an intresting script

![image](https://github.com/user-attachments/assets/082eef96-be28-40f7-b915-2a5be37d898b)

```javascript
<script> 
    $(function() {
        $('#backLink').attr("href", (new URLSearchParams(window.location.search)).get('returnPath'));
    });
</script>
```

It seems to be accessing backlink from the page. It is then giving an attribute called ``href`` now essentially what we are giving to the return path and adding it to a href attribute of the backlink tag.

This seems to be true upon inspecting the page after entering a value of ``test`` in the url.

![image](https://github.com/user-attachments/assets/5ea6da87-d224-4677-9cd8-1e42e40d4ab7)

```
<a id="backLink" href="/test">Back</a>
```
We know now that it has added a href attribute with a value of test. So now we should make a payload that works with href.

```
javascript:alert(1)
```
- javascript: followed by some JavaScript code into the address bar of a browser or in places where a JavaScript expression is allowed
- alert(): as we know is used to display the pop up dialogue 

As such this payload works for href and hence the challenge is solved :D 

We can also see it update in the inspect menu how it has updated

![image](https://github.com/user-attachments/assets/d7ad370f-d855-46cc-949c-6e41ebee6d99)

---

## DOM XSS in jQuery selector sink using a hashchange event

### Challenge

```
This lab contains a DOM-based cross-site scripting vulnerability on the home page. It uses jQuery's $() selector function to auto-scroll to a given post, whose title is passed via the location.hash property.

To solve the lab, deliver an exploit to the victim that calls the print() function in their browser.
```

### Solving

Like last time lets first check what the jQuery code is by checking the source code on the page.

```javascript
<script>
    $(window).on('hashchange', function(){
        var post = $('section.blog-list h2:contains(' + decodeURIComponent(window.location.hash.slice(1)) + ')');
        if (post) post.get(0).scrollIntoView();
    });
</script>
```

We have something called hashchange event. Now essentially when a hashchange event occurs the function is executed.
What it does is it looks for the html element section of the class id block-list then looks for all the h2 headers in it that contains the input.
Essentially looking for a match on the title, if found then it scrolls into view.

What this means is if we add the ``/#titlename`` at the end of a url we instantly scroll to it if a titlename has matched. However when scrolling back to the top we realise that refreshing the page with the added URL
We do not go back to that title unless we modify the url, refresh then change it back and refresh. 

further examination of ``decodeURIComponent(window.location.hash.slice(1))`` this is decoding the URL and our potential input in the URL.

Now this type of jQuery is vulnerable to passing html tags with javascript. Now essentially what we have to do is create a payload that creates a popup to print the page by pushing a payload that uses html to start it.

This challenge is a bit difficult as *we do not go back to that title unless we modify the url, refresh then change it back and refresh.* as mentioned before
where it does not refresh once entered it does not. So a way we can work around this is by passing the URL normally first but it redirects itself to the print function on the hashchange.

We first know that a malicious code payload to this could be ``#<img src=1 onerror=print()>`` which is similar to our last payload where we end up passing a html part to an image with the query of 1 (which does not exist) causing an error 
This error then does the print() and using this at the end of our URL works when printing now lets deal with the earlier issue for triggering the hashchange.

After some research and (looking at the solution) sweating I found this payload.

```javascript
<iframe src="https://0a6600fe04275864d667885100e50085.web-security-academy.net/#" onload="this.src += '<img src=1 onerror=print()>' ">

</iframe>
```

iframe elements as used here are for embedding one web page into another. We have set the URL which sets the current ``https://exploit-0ac00024043b5894d6e287c00125005d.exploit-server.net/exploit/#`` into the webpage, this is the malicious URL that is going to be used to trigger an 
print event solving the challenge. From here we have an onload event which is triggered only when the current URL is finished loading. From here we just provide our HTML error that we cooked up before.
Adding this first opens the page then redirects it to the print which should finish the lab.

To use this we enter the exploit server on burpsuite for this challenge and change the body to this payload. This allows us to also hide the URL payload.

![image](https://github.com/user-attachments/assets/24b9b63b-cfd5-45d4-8bc7-c0b5c8cc5bc1)

Once we have confirmed it starts the print prompt i can then just deliver exploit to victim for a solve and we are done with this lab.

![image](https://github.com/user-attachments/assets/5ada6483-2612-4e39-b682-d4e85313c495)

**NOTE:** When doing this the iframe is visible so to hide it we can change the command to include ``hidden``

![image](https://github.com/user-attachments/assets/3c808978-3c90-4994-8455-c1ad66e4c138)

if its not understandable the item in the top left is not visible.

```javascript
<iframe src="https://0a6600fe04275864d667885100e50085.web-security-academy.net/#" onload="this.src += '<img src=1 onerror=print()>' " hidden="hidden">

</iframe>
```

---

## Reflected XSS into attribute with angle brackets HTML-encoded

### Challenge

```
This lab contains a reflected cross-site scripting vulnerability in the search blog functionality where angle brackets are HTML-encoded. 
To solve this lab, perform a cross-site scripting attack that injects an attribute and calls the alert function.
```

### Solving

Our first step to solving Reflected XSS would be to input test payloads and see what it is doing with it.

Using the test input of ``<test>`` we can see two instances of it being reflected. 
In both cases the lesser than and greater than symbols are encoded. 

![image](https://github.com/user-attachments/assets/d0808e04-d170-43ca-b8c7-baacded0dab6)

However in the second case the reflected value is of the attribute ``value``
Now lets see if the *"* is encoded or not. Testing this we find out that it is within fact not encoded :D

![image](https://github.com/user-attachments/assets/30c48ef8-fb14-47e6-bbe2-bd80a2ad0645)

This essentially allows us to make a new attribute and make a payload through it.

Testing this by searching ``" onclick="alert(1)"`` reflects successfully and when we try to click the textbox to search it shows an error.

However like the previous challenge we have to be sending the link to the victim and once opened it shows this alert function.

so now instead of ``onclick`` we can do something called ``onfocus="alert(1)"``
What this essentially does is execute a javascript when the input field is in focus.
However the input box may not be in focus automatically so how bout we make another attribute to autofocus?

Luckily this attribute name is called ``autofocus``

So our final payload becomes 

``" autofocus onfocus="alert(1)"``

Upon entering this the challenge is solved.

---


## Stored XSS into anchor href attribute with double quotes HTML-encoded

### Challenge 

```
This lab contains a stored cross-site scripting vulnerability in the comment functionality. 
To solve this lab, submit a comment that calls the alert function when the comment author name is clicked.
```
### Solving

This is similar to the blog post website we had hacked earlier so we just select a blog post and we scroll down to the comments.

Now like before we put in our test case to see where it is used and what encoding is present ``<test>`` unlike the previous challenge we are able to pass
this malicious code through website.

![image](https://github.com/user-attachments/assets/2ebb2270-2baa-4d89-8144-ffc98696b410)

Now upon looking through this we realise that the payload passed through the website textfield was not sanitised. It also comes under an anchor tag href attribute.

Now like before when trying to exploit a href attribute we can enter the payload ``javascript:alert(1)``

Now we just go back to the comment and click on the authors name to which we get the alert popup and hence the challenge is solved.

---


## Reflected XSS into a JavaScript string with angle brackets HTML encoded

### Challenge

```
This lab contains a reflected cross-site scripting vulnerability in the search query tracking functionality where angle brackets are encoded. 
The reflection occurs inside a JavaScript string. To solve this lab, perform a cross-site scripting attack that breaks out of the JavaScript string and calls the alert function.
```

### Solving

Opening the lab we again just enter ``<test>`` to see what exactly is encoded and where. And as this is a reflected XSS we will only be able to see actual changes within the inpsect menu.

Doing this i look for where our input went and found 3 instances. Like the challenge says both greater than, lesser than are encoded. 

![image](https://github.com/user-attachments/assets/1af59747-3c50-49ed-ac12-bf3596db6110)

first instance:

``<h1>0 search results for '&lt;test&gt;'</h1>``

second instance:
a script
```javascript
<script>
        var searchTerms = '&lt;test&gt;';
        document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
    </script>
```
third instance:
``<img src="/resources/images/tracker.gif?searchTerms=%26lt%3Btest%26gt%3B">``

In all cases it would seem the symbols ``< >`` are encoded now lets see if the double quotes are encoded.

We make our payload this time `` 'test"``

![image](https://github.com/user-attachments/assets/821b947e-4b62-40cf-9bef-844937047273)

Looking through this we can again see 3 instances. In the first case it is not encoded however it is inbetween header tags making it unusable.

Now looking at the script stuff.

```javascript
<script>
    var searchTerms = ''test"';
    document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
    </script>

```

from this we noteice both the single quotes and double quotes are not encoded.

Now over here we can possibly close the quotes in an area and make our payload.

now more experimentation to see how this works entering a word example hadakoi shows up like this

``var searchTerms = 'hadakoi'``

now that we know the single quotes are not encoded we can make a payload by closing the text field as we have done before in previous challenges

payload : ``test';our malicious code;`` now  essentially searchTerms is set to test and we have closed the text field but we are still able to enter things which will be our payload. 


When i tried making this payload with just ``test';our malicious code;`` it was not working as i was seeing a single quote after this in the html upon inspecting it. We have to put a *'* after the second semi colon as we want to introduce a new string. This is automatically ended with a *'*. This makes the payload valid else it will not run.

So we can make this `` test';alert(1);'breaking ``

Entering this we see the payload has actually worked and provided us the alert.

This hence helps us solve our lab.

---


Proof of solve:

![image](https://github.com/user-attachments/assets/0d091ccc-00bc-43c8-b46e-36ae74040e8d)



