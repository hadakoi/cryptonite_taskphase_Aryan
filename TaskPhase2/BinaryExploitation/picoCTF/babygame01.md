# babygame01

## Method

```
Get the flag and reach the exit.

Welcome to BabyGame! Navigate around the map and see what you can find! The game is available to download here. There is no source available, so you'll have to figure your way around the map. You can connect with it using nc saturn.picoctf.net 58006.
``` 
**Hint 1:** Use 'w','a','s','d' to move around.
**Hint 2:** There may be secret commands to make your life easy.

In this challenge the we are given a game with no extension and a server we can connect to to also play the game.

Upon opening the game we realise that its a type of movement game where we have to reach to the X mark on a map.

This grid is 30 x 90 dots or 29 x 89 in array values.
This is what it looks like: 

```
Player position: 4 4
End tile position: 29 89
Player has flag: 0
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
....@.....................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
.........................................................................................X
```

Looking at the info given when we start the game ``Player position: 4 4`` which we can understand that we start at the 2d array values of 4 and 4 whcih are essentially 5th horizontoally and vertically
We can also see a ``End title position: 29 89`` this coincides with the X mark on the map.

However upon navigating to the end point we see the text You win! but no flag is given.

To solve this we first need to understand how exactly this game works so we shove the game into *ghidra*.

Upon using the analyze option in ghidra we are greeted with a 2 sections

![image](https://github.com/user-attachments/assets/edb39d46-aea3-48a6-bae4-d3b3365b6d1d)

Assembly on the left and a converted C code on the right. Essentially most executable files are in machine code and ghidra first converts it to assembly then converts it to a c Programme.

This is what the converted C code looks like : 

```c

/* WARNING: Function: __x86.get_pc_thunk.bx replaced with injection: get_pc_thunk_bx */
/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */

undefined4 main(void)

{
  int iVar1;
  undefined4 uVar2;
  int in_GS_OFFSET;
  int local_aac;
  int local_aa8;
  char local_aa4;
  undefined local_aa0 [2700];
  int local_14;
  undefined *local_10;
  
  local_10 = &stack0x00000004;
  local_14 = *(int *)(in_GS_OFFSET + 0x14);
  init_player(&local_aac);
  init_map(local_aa0,&local_aac);
  print_map(local_aa0,&local_aac);
  signal(2,sigint_handler);
  do {
    do {
      iVar1 = getchar();
      move_player(&local_aac,(int)(char)iVar1,local_aa0);
      print_map(local_aa0,&local_aac);
    } while (local_aac != 0x1d);
  } while (local_aa8 != 0x59);
  puts("You win!");
  if (local_aa4 != '\0') {
    puts("flage");
    win();
    fflush(_stdout);
  }
  uVar2 = 0;
  if (local_14 != *(int *)(in_GS_OFFSET + 0x14)) {
    uVar2 = __stack_chk_fail_local();
  }
  return uVar2;
}
```
From here we can start understanding the code. 

The first set of lines seem to be declarations for variables after that we start using functions. We can investigate each function by double clicking on them.

``init_player`` and ``init_map`` most likely create and initilize the map and player.

Upon opening init_player we understand that int localc_aac and local_aa8 have 4 written into them and locla_aa4 have 0 written into them.
we can also spot easily that local_aa4 is used to check for a flag. It should not be Null so we can obtain our flag.

inspecting init_map we can see it takes the value of local_aac and the 0 value.
This essentially calculates the x and y value and places our character there.

Looking at ``print_map`` we can just understand that it prints the map we see.

After doing this we enter some loops where we take a character, move the player using a function then print the map.
The loops end when our x and y values enter *0x1d* and *0x59* which are 29 and 89 in decimal respectively.


In each of these functions we are passing local_aa0 which is the stack base pointer in this case. Essentially if we where at the position 0, 0 in the array we would be at local_aa0 which is  the base pointer


Inspecting the move player function 

```c
void move_player(int *param_1,char param_2,int param_3)

{
  int iVar1;
  
  if (param_2 == 'l') {
    iVar1 = getchar();
    player_tile = (undefined)iVar1;
  }
  if (param_2 == 'p') {
    solve_round(param_3,param_1);
  }
  *(undefined *)(*param_1 * 0x5a + param_3 + param_1[1]) = 0x2e;
  if (param_2 == 'w') {
    *param_1 = *param_1 + -1;
  }
  else if (param_2 == 's') {
    *param_1 = *param_1 + 1;
  }
  else if (param_2 == 'a') {
    param_1[1] = param_1[1] + -1;
  }
  else if (param_2 == 'd') {
    param_1[1] = param_1[1] + 1;
  }
  *(undefined *)(*param_1 * 0x5a + param_3 + param_1[1]) = player_tile;
  return;
}
```

As we can see here it has our usual ``w, a, s, d`` from which we understand as our movement keys. However we also see 2 other possible options `l` and `p`.

Looking closer at p we can see a *solve_round* which should essentially solve our round?

Now Looking at the last bit of our code we see a strange function ``*(undefined *)(*param_1 * 0x5a + param_3 + param_1[1]) = player_tile``
This essentially means when we move into the negatives for example what would possibly happen if we where at the array position X, 0 and decide to enter another a to go left?
Trying this we wrap around the text as can be seen when testing in the game.


### Wrapping and going around

Here, *param_1 and param_1[1] are the player's coordinates (x and y) in the 2D grid.
The game calculates the memory offset as:
- *param_1 * 0x5a: Row offset (30 columns per row, 0x5a in hex is 90 in decimal).
- param_3: A base address.
- param_1[1]: Column offset.
Hence allowing a wrap arround 

When the player moves "left" or "right" and the column (param_1[1]) goes negative or exceeds the grid size the calculated memory address overflows or underflows

```
Player position: 4 0
End tile position: 29 89
Player has flag: 0
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
@.........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
.........................................................................................X
a



Player position: 3 89
End tile position: 29 89
Player has flag: 0
..........................................................................................
..........................................................................................
..........................................................................................
.........................................................................................@
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
.........................................................................................X
```

---

### Making the solution

This is most likely due to the last line.
Now Looking back to the "Player has flag: 0" we know that this is *local_aa4* and that this should be overwritten to get the flag back.

So essentially somehow we need to traverse to this local_aa4 to change it.

for this we need to understand how memory works in general.
A stack is like a downward growing shelf in this case new items are placed at the bottom in the order of declarations.

```c
int in_GS_OFFSET;
int local_aac;
int local_aa8;
char local_aa4;
Undefined local_aa0 [2700];
```

From this we understand in_GS_OFFSET is at the highest address in the stack, while local_aa0 is the lowest address which is an array. And local_aa4 is above it which is a variable.

We know that local_aa0 is the stack base pointer and is at the location [0][0] in the array. 

Now considering we have our pointer here  if we try moving our character for eg 4 to the left where would it go? 
As in c it literall means we are accessing it 4 units before the [0][0] which on looking at the stack is aa_4 which is essentially taken as [0][-4]. 
local_aa0[0][-4] is essentially 4 elements before local_aa0[0][0] and over here moves it 4 units to aa4

What happens if you access local_aa0[1][-4]?
You would still be accessing an index from local_aa0, but now you're considering the second element in the array (local_aa0[1]) and then moving 4 units backward from it.
When you do this, you are still within the bounds of the array.

```
+-----+|+-----+|+-----+|+-----+|+-----+
(aa4)  |       |       |       | (aa0)
+-----+|+-----+|+-----+|+-----+|+-----+
 ptr-4 | ptr-3 | ptr-2 | ptr-1 | ptr-0

```

Essentially what I can imagine it as where doing aa0[0][0] points to the first element in the address of aa0.

So now knowing this the first thing i will do is go to the top left.

Once moved here we can do 'a' 4 times moving us to the addres value aa4 by underflowing the player into it and as we can see its now updated with a value of 64. This is because our player has the ``@`` symbol and in ascii is 64. Hence we understand that this writes to the Least Significant Byte (LSB) This means an effective position of { 0, -4 } will write the player_title character to the LSB of local_aa4.

``(*param_1 * 0x5a + param_3 + param_1[1])`` calculates the memory address where the player_tile (a single byte) will be written.
Because player_tile is of type undefined (interpreted as a single byte) only the LSB of that memory address is updated.

Now we can just enter P to satisfy the solve_round hence we get the flag.

*P.S:* I wrote a script to manually do all of this

```python
from pwn import *

# Connect to the remote service
p = remote("saturn.picoctf.net", 58006)

# Send the sequence "wwwwaaaa" to navigate to the top left, Then use the sequence of 4 'a' to move to aa4 then enter p to recieve the flag.
p.sendline("wwwwaaaa")
p.sendline("aaaap")

# Drop into an interactive shell to observe results
p.interactive()

```

## Flag
> picoCTF{gamer_m0d3_enabled_e282d353}
